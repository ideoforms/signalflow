{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SignalFlow: Explore sound synthesis and DSP with Python","text":"<p>SignalFlow is a sound synthesis framework designed for quick and intuitive expression of complex sonic ideas. It has a simple Python API, allowing for rapid prototyping in Jupyter notebooks or on the command-line. It comes with over 100 signal processing classes for creative exploration, from filters and delays to FFT-based spectral processing and Euclidean rhythm generators.</p> <p>Its core is implemented in efficient C++11, with cross-platform hardware acceleration, with cross-platform support for macOS, Linux (including Raspberry Pi) and Windows. </p>"},{"location":"#example","title":"Example","text":"<p>Let's take a look at a minimal SignalFlow example. Here, we create and immediately start the <code>AudioGraph</code>, construct a stereo sine oscillator with a short envelope, connect the oscillator to the graph's output, and run the graph indefinitely.</p> <pre><code>from signalflow import *\n\ngraph = AudioGraph()\nsine = SineOscillator([440, 880])\nenvelope = ASREnvelope(0.1, 0.1, 0.5)\noutput = sine * envelope\noutput.play()\ngraph.wait()\n</code></pre> <p>This demo shows a few syntactical benefits that SignalFlow provides to make it easy to work with audio:</p> <ul> <li>The 2-item array of frequency values passed to <code>SineOscillator</code> is expanded to create a stereo, 2-channel output. If you passed a 10-item array, the output would have 10 channels. (Read more: Multichannel nodes)</li> <li>Mathematical operators like <code>*</code> can be used to multiply, add, subtract or divide the output of nodes, and creates a new output Node that corresponds to the output of the operation. This example uses an envelope to modulate the amplitude of an oscillator. (Read more: Node operators)</li> <li>Even through the envelope is mono and the oscillator is stereo, SignalFlow does the right thing and upmixes the envelope's values to create a stereo output, so that the same envelope shape is applied to the L and R channels of the oscillator, before creating a stereo output. This is called \"automatic upmixing\", and is handy when working with multichannel graphs. (Read more: Automatic upmixing)</li> </ul> <p>In subsequent examples, we will skip the <code>import</code> line and assume you have already imported everything from the <code>signalflow</code> namespace.</p> <p>Info</p> <p>If you want to enforce separation of namespaces, you might want to do something like the below. <pre><code>import signalflow as sf\n\ngraph = sf.AudioGraph()\nsine = sf.SineOscillator(440)\n...\n</code></pre></p>"},{"location":"#overview","title":"Overview","text":"<p>At its core, SignalFlow has a handful of key concepts.</p> <ul> <li>At the top level is the AudioGraph, which connects to the system's audio input/output hardware, and handles the global configuration.</li> <li>The graph comprises of a network of Nodes, each of which performs a single function (for example, generating a cyclical waveform, or filtering an input node). Nodes are connected by input and output relationships: the output of one node may be used to control the frequency of another. As the output of the first node increases, the frequency of the second node increases correspondingly. This modulation is applied on a sample-by-sample basis: all modulation in SignalFlow happens at audio rate.</li> <li>Nodes may have multiple inputs, which determine which synthesis properties can be modulated at runtime.</li> <li>A node can also have Buffer properties, which contain audio waveform data that can be read and written to, for playback or recording of samples. </li> <li>Nodes can be grouped in a Patch, which is a user-defined configuration of nodes. A patch may have one or more named inputs that are defined by the user when creating the patch. Patches can be thought of like voices of a synthesizer. A patch can also be set to automatically remove itself from the graph when a specified node's playback is complete, which is important for automatic memory management.</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installing SignalFlow</li> <li>Example code</li> </ul>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":"<p>SignalFlow tutorials and workshop events follow the Berlin Code of Conduct.</p> <p>The aim of the SignalFlow project is to be inclusive to the largest number of contributors, with the most varied and diverse backgrounds possible. As such, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status and religion (or lack thereof).</p>"},{"location":"code-of-conduct/#reporting-unacceptable-behaviour","title":"Reporting unacceptable behaviour","text":"<p>If you experience or witness unacceptable behaviour at a SignalFlow workshop or tutorial, including intimidating, harassing, abusive, discriminatory, derogatory or demeaning speech or actions, please contact the community organiser, who may take any action appropriate to remedy the behaviour.</p> <p>Please reach out to the workshop organiser or the project coordinator, who will provide assistance. </p> <p>Thank you for helping make this a welcoming, friendly community for all.</p>"},{"location":"examples/","title":"Examples","text":"<p>For code examples using SignalFlow, see GitHub.</p> <p>To download the <code>examples</code> folder locally, execute <code>signalflow download-examples</code> on the command line, or run the below code:</p> <pre><code>import signalflow_examples\n\nsignalflow_examples.download_examples()\n</code></pre>"},{"location":"license/","title":"License","text":""},{"location":"license/#within-python","title":"Within Python","text":"<p>Use of the SignalFlow library with a Python interpreter, script or notebook is licensed under the free and permissive MIT License.</p> <p>This means that you are welcome to use it for any purpose, including commercial usage, but must include the copyright notice above in any copies or derivative works.</p>"},{"location":"license/#embedding-signalflow-within-a-binary","title":"Embedding SignalFlow within a binary","text":"<p>Use of SignalFlow or its components outside of a Python environment (for example, embedded within a binary object) is subject to a separate agreement. Please get in touch to learn more.</p> <p>Please do let me know what you use it for! </p>"},{"location":"buffer/","title":"Buffers","text":"<p>A <code>Buffer</code> is an area of memory that stores single-channel or multi-channel data, which may represent an audio waveform or any other type of signal. </p> <ul> <li>A Buffer can be created from a sound file, an array of samples, a specified dimension, or the result of a function</li> <li>A Buffer can be saved to a sound file</li> <li>A Buffer can be passed to a Node or Patch as an input</li> <li>Buffer sample access can be performed by get/set/fill methods, or directly as a numpy array </li> <li>Buffers can be modified, combined and queried with standard arithmetic operators</li> <li>Buffers can be queried for a number of properties, including interpolation modes and total memory usage</li> <li>TODO: Different Buffer subclasses exist for specific operations, including <code>Buffer2D</code>, <code>WaveshaperBuffer</code> and <code>EnvelopeBuffer</code></li> <li>TODO: Playing a buffer, including sample rate conversion and interpolation</li> <li>TODO: Recording and rendering audio into a Buffer</li> </ul>"},{"location":"buffer/access/","title":"Accessing in memory","text":"<p>The floating-point samples within a SignalFlow <code>Buffer</code> can be read and written directly from Python.</p>"},{"location":"buffer/access/#using-get-and-set-methods","title":"Using get and set methods","text":"<p>The <code>get()</code> and <code>set()</code> methods can be used to access individual samples, indexed by channel and frame offset.</p> <pre><code># Create a 2-channel buffer\nbuf = Buffer(2, 256)\n\n# Set the sample in channel 1 at index 20 to 0.5\nbuf.set(1, 20, 0.5)\n\n# Confirm that the sample is set correctly\nassert buf.get(1, 20) == 0.5\n</code></pre>"},{"location":"buffer/access/#as-a-numpy-array","title":"As a numpy array","text":"<p>The <code>.data</code> property of a <code>Buffer</code> points to a numpy array of shape <code>(num_channels, num_frames)</code>, which can be used to read or write the buffer's data in real time.</p> <pre><code>import time\n\n# Create and play a one-second silent buffer\nbuf = Buffer(2, graph.sample_rate)\nplayer = BufferPlayer(buf, loop=True)\nplayer.play()\n\n# Gradually add crackles to the buffer, which will be heard in real-time\nwhile True:\n    buf.data[0][np.random.randint(0, graph.sample_rate)] = 1.0\n    buf.data[1][np.random.randint(0, graph.sample_rate)] = 1.0\n    time.sleep(1)\n</code></pre>"},{"location":"buffer/access/#filling-a-buffer-with-the-result-of-a-function","title":"Filling a buffer with the result of a function","text":"<p>Just like when creating a buffer, an existing buffer can be filled with the output of a Python function.</p> <p>\u2192 Next: Arithmetic operators</p>"},{"location":"buffer/creating/","title":"Creating a Buffer","text":"<p>A Buffer can be created from:</p> <ul> <li>a sound file</li> <li>an array of samples</li> <li>a specified dimension</li> <li>the result of a function</li> </ul>"},{"location":"buffer/creating/#loading-a-buffer-from-a-sound-file","title":"Loading a buffer from a sound file","text":"<p>To load an audio buffer from a sound file, pass the file path to Buffer's constructor.</p> <pre><code># Load and play a buffer\nbuf = Buffer(\"filename.wav\")\nplayer = BufferPlayer(buf)\nplayer.play()\n</code></pre> <p>The type of the audio file is automatically inferred from the type and contents. Supported formats include <code>wav</code>, <code>aif</code>, <code>mp3</code>, <code>ogg</code>, <code>flac</code>, and many other audio formats. </p> <p>Interally, file I/O is handled by <code>libsndfile</code>. For a full list of supported files, see the libsndfile documentation.</p>"},{"location":"buffer/creating/#creating-a-buffer-from-an-array-of-samples","title":"Creating a buffer from an array of samples","text":"<p>To create and initialise a buffer from an existing array of samples, pass the array to Buffer's constructor. Both native Python arrays and <code>numpy</code> arrays are supported.</p> <p>Note that audio samples should always range between <code>-1.0</code> and <code>1.0</code> to avoid distortion. </p> <pre><code># Initialise a buffer from a native 1D array containing a sawtooth wave\nsamples = [(n % 100) / 100 - 0.5 for n in range(44100)]\nbuf = Buffer(samples)\nplayer = BufferPlayer(buf)\nplayer.play()\n</code></pre> <p>If the array is 1D, a mono buffer will be created. If the array is 2D, a multichannel buffer will be created.</p> <pre><code># Initialise a buffer from a numpy 2D array containing a stereo sine wave\nimport numpy as np\n\nt = np.linspace(0, 1, 44100)\nstereo = np.array([np.sin(220 * t * np.pi * 2),\n                   np.sin(225 * t * np.pi * 2)])\nbuf = Buffer(stereo * 0.1)\nplayer = BufferPlayer(buf)\nplayer.play()\n</code></pre>"},{"location":"buffer/creating/#creating-an-empty-buffer","title":"Creating an empty buffer","text":"<p>An empty buffer can be initialised by specifying its dimensions. All samples will be initialised to zero.</p> <pre><code># Create an empty buffer with 2 channels containing 44100 samples each.\nbuf = Buffer(2, 44100)\n</code></pre>"},{"location":"buffer/creating/#initialising-a-buffer-with-the-result-of-a-function","title":"Initialising a buffer with the result of a function","text":"<p>A buffer can also be populated with the result of a Python function, which takes a single argument containing the index of the frame to be filled.</p> <pre><code># Create a buffer containing a 440Hz ping\nimport numpy as np\nbuf = Buffer(1, graph.sample_rate,\n             lambda frame: np.sin(frame * 440 * np.pi * 2 / graph.sample_rate) * (1 - frame / graph.sample_rate))\nplayer = BufferPlayer(buf)\nplayer.play()\n</code></pre> <p>\u2192 Next: Saving and exporting a buffer</p>"},{"location":"buffer/exporting/","title":"Saving and exporting a buffer","text":""},{"location":"buffer/exporting/#saving-to-a-sound-file","title":"Saving to a sound file","text":"<p>To export a buffer's audio contents to a sound file, use the <code>save()</code> method:</p> <pre><code>import numpy as np\nbuf = Buffer(np.sin(np.linspace(0, 1, graph.sample_rate) * 440 * np.pi * 2))\nbuf.save(\"buffer.wav\")\n</code></pre> <p>The output format will be automatically detected from the filename extension. Supported formats are presently <code>wav</code>, <code>aif</code> and <code>flac</code>.</p> <p>\u2192 Next: Passing a buffer as an input to a node or patch</p>"},{"location":"buffer/input/","title":"Passing a buffer as an input to a node or patch","text":"<p>See:</p> <ul> <li>Node: Buffer inputs</li> <li>Patch: Buffer inputs</li> </ul> <p>\u2192 Next: Accessing a buffer's data in memory</p>"},{"location":"buffer/operators/","title":"Arithmetic operators","text":"<p>Buffers, like nodes, can be manipulated using Python's standard arithmetic operators.</p> <p>For example, to attenuate a buffer, it can be multiplied by a constant value. A new <code>Buffer</code> object is returned, with the same dimensions as the original, scaled by the coefficient.</p> <pre><code>input_buffer = Buffer(\"input.wav\")\nscaled_buffer = input_buffer * 0.5\n# `scaled_buffer` now contains an attenuated version of `input_buffer`\n</code></pre> <p>Below is a full list of operators supported by SignalFlow <code>Buffer</code> objects.</p> Operator Node class <code>+</code> Add <code>-</code> Subtract <code>*</code> Multiply <code>/</code> Divide <p>\u2192 Next: Buffer properties</p>"},{"location":"buffer/properties/","title":"Buffer properties","text":"<p>A <code>Buffer</code> has a number of read-only properties which can be used to query its status at a given moment in time.</p> Property Type Description num_frames int The number of frames (samples) in the buffer. channels int The number of channels in the buffer. sample_rate int The sample rate of the buffer. duration float The duration of the buffer, in seconds. filename str If the buffer has been loaded from/saved to a file, the absolute path to the file. interpolation_mode str The interpolation mode of the buffer. [LINK]"},{"location":"graph/","title":"The AudioGraph","text":"<p><code>AudioGraph</code> is the global audio processing system that schedules and performs audio processing. It is comprised of an interconnected network of Node and Patch objects, which audio flows through.</p> <p>Each time a new block of audio is requested by the system audio I/O layer, the <code>AudioGraph</code> object is responsible for traversing the tree of nodes and generating new samples by calling each <code>Node</code>'s <code>process</code> method.</p> <p>Why 'Graph'?</p> <p>You may be more familiar with \"graph\" being used to mean a data visualisation. In signal processing and discrete mathematics, the term \"graph\" is also used to denote a system of nodes related by connections. Read more: Graph Theory Basics (Lumen Learning). </p> <p>\u2192 Next: Creating the graph</p>"},{"location":"graph/config/","title":"The AudioGraph","text":""},{"location":"graph/config/#graph-configuration","title":"Graph configuration","text":"<p>There are a number of graph configuration parameters that can be used to change the global behaviour of the audio system. This can be done programmatically, via a config file, or via environmental variables.</p> Parameter Description backend_name The name of the audio backend to use, which can be one of: <code>jack</code>, <code>alsa</code>, <code>pulseaudio</code>, <code>coreaudio</code>, <code>wasapi</code>, <code>dummy</code>. Defaults to the first of these found on the system. Typically only required for Linux. output_device_name The name of the audio output device to use. Note  If not found, <code>DeviceNotFoundException</code> is thrown when instantiating the graph. output_buffer_size The size of the hardware output audio buffer, in samples. A larger buffer reduces the chance of buffer overflows and glitches, but at the cost of higher latency. Note that this config option merely specifies the preferred output buffer size, which may not be available in the system hardware. To check the actual buffer size used by the AudioGraph, query <code>graph.output_buffer_size</code> after instantiation. input_device_name The name of the input device to use. input_buffer_size The size of the hardware input audio buffer. sample_rate The audio sample rate to use. cpu_usage_limit Imposes a hard limit on the CPU usage permitted by SignalFlow. If the estimated (single-core) CPU usage exceeds this value, no more nodes or patches can be created until it returns to below the limit. Floating-point value between 0..1, where 0.5 means 50% CPU. auto_record If true, automatically records the graph's audio output to a timestamped file in <code>~/.signalflow/recordings</code>. A true value can be any of \"true\", \"yes\", \"on\", or 1."},{"location":"graph/config/#configuring-the-graph-programmatically","title":"Configuring the graph programmatically","text":"<p>To specify an alternative config, create and populate an <code>AudioGraphConfig</code> object before the graph is started:</p> <pre><code>config = AudioGraphConfig()\nconfig.output_device_name = \"MacBook Pro Speakers\"\nconfig.sample_rate = 44100\nconfig.output_buffer_size = 2048\n\ngraph = AudioGraph(config)\n</code></pre>"},{"location":"graph/config/#configuring-the-graph-via-signalflowconfig","title":"Configuring the graph via ~/.signalflow/config","text":"<p>To specify a configuration that is used by all future SignalFlow sessions, create a file <code>~/.signalflow/config</code>, containing one or more of the \"Graph configuration\" fields listed above.</p> <p>For example:</p> <pre><code>[audio]\nsample_rate = 48000\noutput_buffer_size = 256\ninput_buffer_size = 256\noutput_device_name = \"MacBook Pro Speakers\"\ninput_device_name = \"MacBook Pro Microphone\"\n</code></pre> <p>All fields are optional.</p> <p>A quick and easy way to edit your config, or create a new config file, is by using the <code>signalflow</code> command-line utility:</p> <pre><code>signalflow configure\n</code></pre> <p>This will use your default <code>$EDITOR</code> to open the configuration, or <code>pico</code> if no editor is specified.</p>"},{"location":"graph/config/#configuring-the-graph-via-environmental-variables","title":"Configuring the graph via environmental variables","text":"<p>SignalFlow config can also be set by setting an environmental variable in your shell. Variable names are identical to the upper-case version of the config string, prefixed with <code>SIGNALFLOW_</code>. For example:</p> <pre><code>export SIGNALFLOW_OUTPUT_DEVICE_NAME=\"MacBook Pro Speakers\"\nexport SIGNALFLOW_OUTPUT_BUFFER_SIZE=1024\nexport SIGNALFLOW_AUTO_RECORD=true\n</code></pre>"},{"location":"graph/config/#printing-the-current-config","title":"Printing the current config","text":"<p>To print the current configuration to stdout:</p> <pre><code>graph.config.print()\n</code></pre> <p>\u2192 Next: Graph status and properties</p>"},{"location":"graph/creating/","title":"The AudioGraph","text":""},{"location":"graph/creating/#creating-the-graph","title":"Creating the graph","text":"<p>Creating the graph is simple: <code>graph = AudioGraph()</code></p> <p>By default, a new <code>AudioGraph</code> immediately connects to the system's default audio hardware device (via the integrated <code>libsoundio</code> library), using the system's default sample rate and buffer size.</p> <p>Info</p> <p>Note that the AudioGraph is a singleton object: only one AudioGraph can be created, which is shared globally.</p> <p>To prevent the graph from starting instantly (for example, if you want to use the graph in offline mode), pass <code>start=False</code> to the constructor.</p> <p>To configure graph playback or recording parameters, see AudioGraph: Configuration.</p> <p>\u2192 Next: Graph configuration</p>"},{"location":"graph/properties/","title":"The AudioGraph","text":""},{"location":"graph/properties/#status-and-properties","title":"Status and properties","text":"<p>A number of methods are provided to query the graph's current status and properties.</p>"},{"location":"graph/properties/#status","title":"Status","text":"<p>Querying <code>graph.status</code> returns a one-line description of the number of nodes and patches in the graph, and the estimated CPU and RAM usage:</p> <pre><code>&gt;&gt;&gt; graph.status\nAudioGraph: 235 active nodes, 6 patches, 13.95% CPU usage, 34.91MB memory usage\n</code></pre> <p>To automatically poll and print the graph's status periodically, call <code>graph.poll(interval)</code>, where <code>interval</code> is in seconds:</p> <pre><code>&gt;&gt;&gt; graph.poll(1)\nAudioGraph: 118 active nodes, 3 patches, 7.09% CPU usage, 34.91MB memory usage\nAudioGraph: 118 active nodes, 3 patches, 7.16% CPU usage, 34.91MB memory usage\nAudioGraph: 40 active nodes, 1 patch, 2.60% CPU usage, 34.91MB memory usage\n</code></pre> <p>To stop polling, call <code>graph.poll(0)</code>.</p>"},{"location":"graph/properties/#structure","title":"Structure","text":"<p>Querying <code>graph.structure</code> returns a multi-line string describing every Node in the graph, their parameter values, and their connectivity structure.</p> <pre><code>&gt;&gt;&gt; graph.structure\n * audioout-soundio\n   input0:\n    * linear-panner\n      pan: 0.000000\n      input:\n       * multiply\n         input1: 0.251189\n         input0:\n          * sine\n            frequency: 440.000000\n</code></pre>"},{"location":"graph/properties/#other-graph-properties","title":"Other graph properties","text":"<ul> <li><code>graph.node_count</code> (int): Returns the current number of Nodes in the graph (including within patches)</li> <li><code>graph.patch_count</code> (int): Returns the current number of Patches in the graph</li> <li><code>cpu_usage</code> (float): Returns the current CPU usage, between 0.0 (0%) and 1.0 (100%). CPU usage can be lowered by increasing the output buffer size.</li> <li><code>memory_usage</code> (int): Returns the current RAM usage, in bytes. This is typically mostly used by waveform data in Buffers.</li> <li><code>num_output_channels</code> (int): Returns the graph's current output channel count, which is typically identical to the number of channels supported by the audio output device.</li> <li><code>output_buffer_size</code> (int): Returns the current hardware output buffer size, in bytes.</li> </ul> <p>\u2192 Next: Recording graph output</p>"},{"location":"graph/recording/","title":"The AudioGraph","text":""},{"location":"graph/recording/#recording-the-audio-output-of-the-graph","title":"Recording the audio output of the graph","text":"<p>Convenience methods are provided to make it easy to record the global audio output when rendering audio in real-time:</p> <pre><code>graph.start_recording(\"filename.wav\")\n...\ngraph.stop_recording()\n</code></pre> <p>To record output in formats other than the default stereo, <code>start_recording</code> takes a <code>num_channels</code> argument that can be used to specify an alternative channel count.</p> <p>Note</p> <p>At present, only .wav is supported as an output format for global audio recordings. </p>"},{"location":"graph/recording/#offline-non-real-time-rendering","title":"Offline (non-real-time) rendering","text":"<p>It is also possible to perform non-real-time rendering of a synthesis graph,  by synthesizing audio output to a <code>Buffer</code> which can then be saved to disk:   </p> <pre><code># Create an AudioGraph with a dummy output device\ngraph = AudioGraph(output_device=AudioOut_Dummy(2))\n\n# Create a buffer that will be used to store the audio output\nbuffer = Buffer(2, graph.sample_rate * 4)\n\n# Create a synthesis graph to render\nfreq = SawLFO(1, 200, 400)\nsine = SineOscillator([freq, freq+10])\ngraph.play(sine)\n\n# Render to the buffer. Non-real-time, so happens instantaneously.\n# Note that the graph renders as many samples as needed to fill the buffer.\ngraph.render_to_buffer(buffer)\n\n# Write the buffer contents to a file\nbuffer.save(\"output.wav\")\n\n# Finally, tear down the buffer\ngraph.destroy()\n</code></pre> <p>\u2192 Next: Clearing and stopping the graph</p>"},{"location":"graph/stopping/","title":"The AudioGraph","text":""},{"location":"graph/stopping/#clearing-and-stopping-the-graph","title":"Clearing and stopping the graph","text":"<p>To clear all nodes and patches from the graph but leave it running for further audio synthesis:</p> <pre><code>&gt;&gt;&gt; graph.clear()\n</code></pre> <p>To stop the graph and pause audio I/O:</p> <pre><code>&gt;&gt;&gt; graph.stop()\n</code></pre> <p>To permanently destroy the graph:</p> <pre><code>&gt;&gt;&gt; graph.destroy()\n</code></pre>"},{"location":"howto/","title":"Howto","text":"<p>Warning</p> <p>This documentation is a work-in-progress and may have sections that are missing or incomplete.</p> <p>Tutorials on common tasks with SignalFlow.</p>"},{"location":"howto/midi/","title":"Howto: MIDI control","text":""},{"location":"howto/plotting/","title":"Howto: Plotting and visualisation","text":"<p>The output of a SignalFlow AudioGraph can be plotted using the popular matplotlib plotting library.</p> <p>To install the library: <code>pip install matplotlib</code></p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom signalflow import *\n\nconfig = AudioGraphConfig()\nconfig.output_buffer_size = 4096\ngraph = AudioGraph(output_device=AudioOut_Dummy(buffer_size=2048),\n                   config=config)\n\nosc = SawOscillator(500)\nosc.play()\nbuf = graph.render_to_new_buffer(4410)\n\n#--------------------------------------------------------------------------------\n# Plot graphs\n#--------------------------------------------------------------------------------\nfig, axs = plt.subplots(nrows=2, figsize=(12, 5), dpi=200)\naxs[0].plot(buf.data[0])\naxs[1].magnitude_spectrum(buf.data[0], Fs=graph.sample_rate)\n\nplt.show()\n</code></pre>"},{"location":"howto/plotting/#output","title":"Output","text":""},{"location":"installation/","title":"Getting started","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>SignalFlow requires Python 3.8 or above, on the following systems:</p> <ul> <li>macOS: Catalina (10.15) and above</li> <li>Windows: Windows 10 and above (64-bit)</li> <li>Linux: Any Linux on an x86_64 processor</li> <li>Raspberry Pi: Raspberry Pi 3 Model B and above (64-bit)</li> </ul>"},{"location":"installation/#installation","title":"Installation","text":"<p>If you're new to Python or getting started from scratch, the tutorial below will walk you through the setup process with Visual Studio Code.</p> <p>Easy install with Visual Studio Code</p>"},{"location":"installation/#command-line-installation","title":"Command-line installation","text":"<p>If you are an existing Python user and confident with the command line:</p> <p>Install from the command line</p>"},{"location":"installation/#examples","title":"Examples","text":"<p>Several example scripts are included within the repo, covering simple control and modulation, FM synthesis, sample granulation, MIDI control, chaotic functions, etc.</p>"},{"location":"installation/command-line/","title":"Command-line installation","text":""},{"location":"installation/command-line/#1-set-up-a-virtual-environment","title":"1. Set up a virtual environment","text":"<p>Creating a new virtual environment for SignalFlow minimises the chances of conflict with other local Python installs.</p> <pre><code>python3 -m venv signalflow-env\nsource signalflow-env/bin/activate\n</code></pre>"},{"location":"installation/command-line/#2-install-signalflow","title":"2. Install SignalFlow","text":"<p>Installing SignalFlow with <code>pip</code>:</p> <pre><code>pip3 install signalflow\n</code></pre> <p>If the installation succeeds, you should see <code>Successfully installed signalflow</code>.</p>"},{"location":"installation/command-line/#3-line-test","title":"3. Line test","text":"<p>The installation of SignalFlow includes a command-line tool, <code>signalflow</code>, that can be used to test and configure the framework. Check that the installation has succeeded by playing a test tone through your default system audio output:</p> <p>This may take a few seconds to run for the first time. To exit the test, press Ctrl-C (<code>^C</code>).</p> <pre><code>signalflow test\n</code></pre>"},{"location":"installation/command-line/#4-hello-world","title":"4. Hello, world","text":"<p>In your text editor, create a new <code>.py</code> file containing the below code:</p> <pre><code>from signalflow import *\n\ngraph = AudioGraph()\nsine = SineOscillator([440, 880])\nenvelope = ASREnvelope(0.1, 0.1, 0.5)\noutput = sine * envelope * 0.1\noutput.play()\ngraph.wait()\n</code></pre> <p>When you run the script, you should hear a short stereo \"ping\".</p>"},{"location":"installation/command-line/#5-optional-interactive-notebooks-in-jupyter","title":"5. (Optional) Interactive notebooks in Jupyter","text":"<p>A nice way to experiment with SignalFlow is by using Jupyter interactive notebooks.</p> <p>Install Jupyter and register this virtual environment as a Jupyter kernel: </p> <pre><code>pip3 install jupyter\npython3 -m ipykernel install --name signalflow-env\n</code></pre> <p>Open a Jupyter notebook:</p> <pre><code>jupyter notebook\n</code></pre>"},{"location":"installation/easy/","title":"SignalFlow: Easy install with Visual Studio Code","text":"<p>The simplest way to start exploring SignalFlow is with the free Visual Studio Code editor. Visual Studio Code can edit interactive Jupyter notebooks, allowing you to run and modify blocks of Python code in real-time, which is a great way to experiment live with audio synthesis.</p> <p>You'll only need to do this installation process once. Once set up, experimenting with SignalFlow is as simple as opening Visual Studio Code.  </p>"},{"location":"installation/easy/#1-install-python","title":"1. Install Python","text":"<p>Download and install the latest version of Python.</p> <p>Download Python</p>"},{"location":"installation/easy/#2-download-and-install-visual-studio-code","title":"2. Download and install Visual Studio Code","text":"<p>Download and install the latest version of Visual Studio Code.</p> <p>Download Visual Studio Code</p> <p>Once installed, open Visual Studio Code.</p>"},{"location":"installation/easy/#3-install-the-python-and-jupyter-extensions","title":"3. Install the Python and Jupyter extensions","text":"<p>Visual Studio Code requires extensions to be installed to handle Python and Jupyter files.</p> <p>In Visual Studio Code, select the <code>Extensions</code> icon from in the far-left column, and install the <code>Python</code> and <code>Jupyter</code> extensions by searching for their names and clicking \"Install\" on each.</p> <p>Once installation has finished, close the <code>Extensions</code> tab.</p>"},{"location":"installation/easy/#4-create-a-new-workspace","title":"4. Create a new workspace","text":"<p>In Visual Studio code, create a new folder to contain your new SignalFlow project:</p> <ul> <li>Select <code>File \u2192 Open Folder...</code></li> <li>Select <code>New Folder</code>, and pick a name for your new project folder</li> </ul> <p>Where to put your workspace</p> <p>You can store your project workspace anywhere on your drive. The workspace can hold multiple notebooks, audio files, etc.</p> <p>Trusted workspaces</p> <p>If Visual Studio asks \"Do you trust the authors of the files in this folder?\", select \"Yes, I trust the authors\". This is a security mechanism to protect you against untrusted third-party code.</p>"},{"location":"installation/easy/#5-create-a-notebook","title":"5. Create a notebook","text":"<p>Select <code>File \u2192 New File...</code>, and select <code>Jupyter Notebook</code>. You should see the screen layout change to display an empty black text block (in Jupyter terminology, a \"cell\"). </p>"},{"location":"installation/easy/#6-create-a-python-virtual-environment-to-use","title":"6. Create a Python virtual environment to use","text":"<p>Click the button marked <code>Select Kernel</code> in the top right. </p> <ul> <li>Select <code>Python Environments...</code></li> <li>Select <code>Create Python Environment</code></li> <li>Select <code>Venv</code></li> <li>Finally, select the version of Python you just installed.</li> </ul> <p>Multiple versions of Python?</p> <p>If you already have one or more versions of Python installed, any version from Python 3.8 upwards is fine.</p> <p>Visual Studio Code will launch into some activity, in which it is installing necessary libraries and creating a Python \"virtual environment\", which is an isolated area of the filesystem containing all the packages needed for this working space. Working in different virtual environments for different projects is good practice to minimise the likelihood of conflicts and disruptions.</p> <p>When the setup is complete, the button in the top right should change to say <code>.venv (Python 3.x.x)</code>.</p> <p>Info</p> <p>New notebooks created within this workspace will share the same Python virtual environment.  </p>"},{"location":"installation/easy/#7-install-signalflow","title":"7. Install SignalFlow","text":"<p>In the first block, copy and paste the below:</p> <pre><code>%pip install signalflow\n</code></pre> <p>To run the cell, press <code>Ctrl-Enter</code>. After a minute, you should see some output saying <code>Successfully installed signalflow</code>.</p> <p>Running cells with '.venv' requires the ipykernel package.</p> <p>If you are given a prompt that the <code>ipykernel</code> package is required, press \"Install\" to install the package.</p> <p>You're now all set to start writing code!</p>"},{"location":"installation/easy/#8-start-writing-code","title":"8. Start writing code","text":"<p>In a Jupyter interactive notebook, you can write and run multi-line blocks of Python code. Press <code>enter</code> to edit the cell, delete its contents, and paste the below.    </p> <pre><code>print(\"Hello\")\nprint(\"world!\")\n</code></pre> <p>Press <code>Ctrl-Enter</code> to run the cell. You should see \"Hello world!\" appear below the cell. </p> <p>Keyboard shortcuts</p> <ul> <li>Navigate between cells with the arrow keys</li> <li>Press <code>enter</code> to begin editing a cell, and <code>escape</code> to end editing and move to select mode</li> <li>In select mode, use <code>b</code> to add a cell after the current cell, and <code>a</code> to add a cell before it </li> <li>To evaluate a cell and move on to the next cell, use <code>\u21e7\u21b5</code> (shift-enter)</li> </ul>"},{"location":"installation/easy/#9-signalflow-import-the-library-and-start-audio-processing","title":"9. SignalFlow: Import the library and start audio processing","text":"<p>Clear the first cell, and replace it with:</p> <pre><code>from signalflow import *\n</code></pre> <p>Run the cell with <code>Ctrl-Enter</code>. This command imports all of the SignalFlow commands and classes, and only needs to be run once per session.</p> <p>Create a new cell by pressing <code>b</code>, and in the new cell, run:</p> <pre><code>graph = AudioGraph()\n</code></pre> <p>This will create and start a new global audio processing graph, using the system's default audio output. You should see the name of the audio device printed to the notebook.</p> <p>This also needs to be run once per session. In fact, only one global <code>AudioGraph</code> object can be created.  </p>"},{"location":"installation/easy/#10-signalflow-make-some-sound","title":"10. SignalFlow: Make some sound","text":"<p>We're finally ready to make some noise!</p> <p>In a new cell, copy and paste the below:</p> <pre><code>sine = SineOscillator(440)\npanner = StereoPanner(sine, 0.0)\noutput = panner * 0.1\noutput.play()\n</code></pre> <p>This will create a simple sine wave oscillator, pan it over a stereo pair, attenuate it, and play it from the system's audio output. Hopefully you should now hear a tone playing from your speaker or headphones.</p> <p>One of the benefits of coding interactively is that you can modify the parameters of a synthesis network while it is running. In a new cell, try modifying the <code>frequency</code> property of the oscillator:</p> <pre><code>sine.frequency = 880\n</code></pre> <p>You should hear it increase in pitch. Try changing the value to something different and re-running the cell.</p> <p>The <code>pan</code> property of <code>StereoPanner</code> controls its position in the stereo field from left to right, and can range from <code>-1</code> to <code>1</code>:</p> <pre><code>panner.pan = -1\n</code></pre> <p>Finally, to stop all playback:</p> <pre><code>graph.clear()\n</code></pre>"},{"location":"installation/easy/#next-steps","title":"Next steps","text":"<ul> <li>Examples: Several example scripts are available for SignalFlow, covering simple control and modulation, FM synthesis, sample granulation, MIDI control, chaotic functions, etc.</li> <li>Configuration: To configure your audio hardware, see AudioGraph configuration.</li> <li>Tutorials: Coming soon</li> </ul>"},{"location":"installation/next-steps/","title":"Next steps","text":""},{"location":"installation/next-steps/#next-steps","title":"Next steps","text":"<ul> <li>Examples: Several example scripts are available for SignalFlow, covering simple control and modulation, FM synthesis, sample granulation, MIDI control, chaotic functions, etc.</li> <li>Configuration: To configure your audio hardware, see AudioGraph configuration.</li> <li>Tutorials: Coming soon</li> </ul>"},{"location":"internals/hardware-io/","title":"How SignalFlow handles hardware I/O","text":"<p>Preferred hardware settings are set in AudioGraphConfig, and are handled as below.</p> <ul> <li><code>sample_rate</code>: Sets the audio sample rate of the graph. If unspecified, the hardware's underlying native sample rate is used. On Core Audio, this also sets the preferred sample rate of the underlying hardware, and the nearest available sample rate is used. If the configured sample rate does not match the hardware's native sample rate, miniaudio resamples the audio automatically. Note that the same sample rate must currently be used for both input and output devices. </li> <li><code>buffer_size</code>: Sets the preferred buffer size, in frames. </li> <li><code>backend_name</code>: Different backends cannot be used for different input and output devices, because they share the same callback in the underlying audio abstraction layer.  </li> <li><code>output_device_name</code></li> <li><code>input_device_name</code></li> </ul>"},{"location":"library/","title":"Node reference library","text":""},{"location":"library/#analysis","title":"Analysis","text":"<ul> <li>CrossCorrelate: Outputs the cross-correlation of the input signal with the given buffer. If hop_size is zero, calculates the cross-correlation every sample.</li> <li>NearestNeighbour: Nearest Neighbour.</li> <li>OnsetDetector: Simple time-domain onset detector: outputs an impulse when an onset is detected in the input.</li> <li>VampAnalysis: Feature extraction using the Vamp plugin toolkit.</li> </ul>"},{"location":"library/#buffer","title":"Buffer","text":"<ul> <li>BeatCutter: Cuts a buffer into segment_count segments, and stutters/jumps with the given probabilities.</li> <li>BufferLooper: Read and write from a buffer concurrently, with controllable overdub.</li> <li>BufferPlayer: Plays the contents of the given buffer. <code>start_time</code>/<code>end_time</code> are in seconds. When a <code>clock</code> signal is received, rewinds to the <code>start_time</code>.</li> <li>BufferRecorder: Records the input to a buffer. feedback controls overdub.</li> <li>FeedbackBufferReader: Counterpart to FeedbackBufferWriter.</li> <li>FeedbackBufferWriter: Counterpart to FeedbackBufferReader.</li> <li>HistoryBufferWriter: Writes a rolling history buffer of a given duration. At a given moment in time, the contents of the buffer will be equal to the past N seconds of the audio generated by <code>input</code>.</li> <li>SegmentPlayer: Trigger segments of <code>buffer</code> at the given list of <code>onsets</code> positions, in seconds.</li> </ul>"},{"location":"library/#buffer-granulation","title":"Buffer: Granulation","text":"<ul> <li>SegmentedGranulator: Segmented Granulator.</li> <li>Granulator: Granulator. Generates a grain from the given buffer each time a trigger is received on the <code>clock</code> input. Each new grain uses the given <code>duration</code>, <code>amplitude</code>, <code>pan</code> and <code>rate</code> values presented at each input at the moment the grain is created. The input buffer can be mono or stereo. If <code>wrap</code> is true, grain playback can wrap around the end/start of the buffer.</li> </ul>"},{"location":"library/#control","title":"Control","text":"<ul> <li>MouseX: Outputs the normalised cursor X position, from 0 to 1. Currently only supported on macOS.</li> <li>MouseY: Outputs the normalised cursor Y position, from 0 to 1. Currently only supported on macOS.</li> <li>MouseDown: Outputs 1 if the left mouse button is down, 0 otherwise. Currently only supported on macOS.</li> </ul>"},{"location":"library/#envelope","title":"Envelope","text":"<ul> <li>Accumulator: Accumulator with decay.</li> <li>ADSREnvelope: Attack-decay-sustain-release envelope. Sustain portion is held until gate is zero.</li> <li>ASREnvelope: Attack-sustain-release envelope.</li> <li>DetectSilence: Detects blocks of silence below the threshold value. Used as an auto-free node to terminate a Patch after processing is complete.</li> <li>Envelope: Generic envelope constructor, given an array of levels, times and curves.</li> <li>Line: Line segment with the given start/end values, and duration (in seconds). If loop is true, repeats indefinitely. Retriggers on a clock signal.</li> <li>RectangularEnvelope: Rectangular envelope with the given sustain duration.</li> </ul>"},{"location":"library/#fft","title":"FFT","text":"<ul> <li>FFTContinuousPhaseVocoder: Continuous phase vocoder. Requires an FFT* input.</li> <li>FFTConvolve: Frequency-domain convolution, using overlap-add. Useful for convolution reverb, with the input buffer containing an impulse response. Requires an FFT* input.</li> <li>FFTBufferPlayer: FFTBufferPlayer. Plays from a buffer of audio spectra in mag/phase format.</li> <li>FFTContrast: FFT Contrast. Requires an FFT* input.</li> <li>FFTCrossFade: FFT FFTCrossFade. Requires two FFT* inputs.</li> <li>FFTLFO: FFT LFO. Requires an FFT* input.</li> <li>FFTMagnitudePhaseArray: Fixed mag/phase array.</li> <li>FFTRandomPhase: Randomise phase values.</li> <li>FFTScaleMagnitudes: Randomise phase values.</li> <li>FFTTransform: Transforms the FFT magnitude spectrum in the X axis. Requires an FFT* input.</li> <li>FFT: Fast Fourier Transform. Takes a time-domain input, and generates a frequency-domain (FFT) output.</li> <li>FFTFindPeaks: Find peaks in the FFT magnitude spectrum. Requires an FFT* input.</li> <li>IFFT: Inverse Fast Fourier Transform. Requires an FFT* input, generates a time-domain output.</li> <li>FFTLPF: FFT-based brick wall low pass filter. Requires an FFT* input.</li> <li>FFTNoiseGate: FFT-based noise gate. Requires an FFT* input.</li> <li>FFTPhaseVocoder: Phase vocoder. Requires an FFT* input.</li> <li>FFTTonality: Tonality filter. Requires an FFT* input.</li> <li>FFTZeroPhase: Remove phase information from a frequency-domain input. Requires an FFT* input.</li> </ul>"},{"location":"library/#operators","title":"Operators","text":"<ul> <li>Add: Add each sample of a to each sample of b. Can also be written as a + b</li> <li>AmplitudeToDecibels: Map a linear amplitude value to decibels.</li> <li>DecibelsToAmplitude: DecibelsToAmplitude</li> <li>Bus: Bus is a node with a fixed number of input channels and arbitrary number of inputs, used to aggregate multiple sources. It is similar to Sum, but with a defined channel count that does not adapt to its inputs.</li> <li>ChannelArray: Takes an array of inputs and spreads them across multiple channels of output.</li> <li>ChannelCrossfade: Given a multichannel input, crossfades between channels based on the given position within the virtual array, producing a single-channel output.</li> <li>ChannelMixer: Downmix a multichannel input to a lower-channel output. If num_channels is greater than one, spreads the input channels across the field. If amplitude_compensation is enabled, scale down the amplitude based on the ratio of input to output channels.</li> <li>ChannelOffset: Offsets the input by a specified number of channels. With an N-channel input and an offset of M, the output will have M+N channels.</li> <li>ChannelSelect: Select a subset of channels from a multichannel input, starting at offset, up to a maximum of maximum, with the given step.</li> <li>Equal: Compares the output of a to the output of b. Outputs 1 when equal, 0 otherwise. Can also be written as a == b</li> <li>NotEqual: Compares the output of a to the output of b. Outputs 0 when equal, 1 otherwise. Can also be written as a != b</li> <li>GreaterThan: Compares the output of a to the output of b. Outputs 1 when a &gt; b, 0 otherwise. Can also be written as a &gt; b</li> <li>GreaterThanOrEqual: Compares the output of a to the output of b. Outputs 1 when a &gt;= b, 0 otherwise. Can also be written as a &gt;= b</li> <li>LessThan: Compares the output of a to the output of b. Outputs 1 when a &lt; b, 0 otherwise. Can also be written as a &lt; b</li> <li>LessThanOrEqual: Compares the output of a to the output of b. Outputs 1 when a &lt;= b, 0 otherwise. Can also be written as a &lt;= b</li> <li>Modulo: Outputs the value of a modulo b, per sample. Supports fractional values. Can also be written as a % b</li> <li>Abs: Outputs the absolute value of a, per sample. Can also be written as abs(a)</li> <li>If: Outputs value_if_true for each non-zero value of a, value_if_false for all other values.</li> <li>Divide: Divide each sample of a by each sample of b. Can also be written as a / b</li> <li>FrequencyToMidiNote: Map a frequency to a MIDI note (where 440Hz = A4 = 69), with floating-point output.</li> <li>MidiNoteToFrequency: Map a MIDI note to a frequency (where 440Hz = A4 = 69), supporting floating-point input.</li> <li>Multiply: Multiply each sample of a by each sample of b. Can also be written as a * b</li> <li>Pow: Outputs a to the power of b, per sample. Can also be written as a ** b</li> <li>RoundToScale: Given a frequency input, generates a frequency output that is rounded to the nearest MIDI note. (TODO: Not very well named)</li> <li>Round: Round the input to the nearest integer value.</li> <li>ScaleLinExp: Scales the input from a linear range (between a and b) to an exponential range (between c and d).</li> <li>ScaleLinLin: Scales the input from a linear range (between a and b) to a linear range (between c and d).</li> <li>SelectInput: Pass through the output of one or more <code>inputs</code>, based on the integer input index specified in <code>index</code>. Unlike <code>ChannelSelect</code>, inputs may be multichannel, and <code>index</code> can be modulated in real time.</li> <li>Subtract: Subtract each sample of b from each sample of a. Can also be written as a - b</li> <li>Sum: Sums the output of all of the input nodes, by sample.</li> <li>TimeShift: TimeShift</li> <li>Sin: Outputs sin(a), per sample.</li> <li>Cos: Outputs cos(a), per sample.</li> <li>Tan: Outputs tan(a), per sample.</li> <li>Tanh: Outputs tanh(a), per sample. Can be used as a soft clipper.</li> </ul>"},{"location":"library/#oscillators","title":"Oscillators","text":"<ul> <li>Impulse: Produces a value of 1 at the given <code>frequency</code>, with output of 0 at all other times. If frequency is 0, produces a single impulse.</li> <li>SawLFO: Produces a sawtooth LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</li> <li>SawOscillator: Produces a (non-band-limited) sawtooth wave, with the given <code>frequency</code> and <code>phase</code> offset. When a <code>reset</code> or trigger is received, resets the phase to zero.</li> <li>SineLFO: Produces a sinusoidal LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</li> <li>SineOscillator: Produces a sine wave at the given <code>frequency</code>.</li> <li>SquareLFO: Produces a pulse wave LFO with the given <code>frequency</code> and pulse <code>width</code>,  ranging from <code>min</code> to <code>max</code>, where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</li> <li>SquareOscillator: Produces a pulse wave with the given <code>frequency</code> and pulse <code>width</code>,  where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</li> <li>TriangleLFO: Produces a triangle LFO with the given <code>frequency</code> and <code>phase</code> offset, ranging from <code>min</code> to <code>max</code>.</li> <li>TriangleOscillator: Produces a triangle wave with the given <code>frequency</code>.</li> <li>Wavetable: Plays the wavetable stored in buffer at the given <code>frequency</code> and <code>phase</code> offset. <code>sync</code> can be used to provide a hard sync input, which resets the wavetable's phase at each zero-crossing.</li> <li>Wavetable2D: Wavetable2D</li> </ul>"},{"location":"library/#physical","title":"Physical","text":"<ul> <li>Maraca: Physically-inspired model of a maraca.</li> </ul>"},{"location":"library/#processors","title":"Processors","text":"<ul> <li>Clip: Clip the input to <code>min</code>/<code>max</code>.</li> <li>Fold: Fold the input beyond <code>min</code>/<code>max</code>, reflecting the excess back.</li> <li>Smooth: Smooth the input with a given smoothing coefficient. When <code>smooth</code> = 0, applies no smoothing.</li> <li>WetDry: Takes <code>wet</code> and <code>dry</code> inputs, and outputs a mix determined by <code>wetness</code>.</li> <li>Wrap: Wrap the input beyond <code>min</code>/<code>max</code>.</li> </ul>"},{"location":"library/#processors-delays","title":"Processors: Delays","text":"<ul> <li>AllpassDelay: All-pass delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>CombDelay: Comb delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>OneTapDelay: Single-tap delay line. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>Stutter: Stutters the input whenever a trigger is received on <code>clock</code>. Generates <code>stutter_count</code> repeats, with duration of <code>stutter_time</code>.</li> </ul>"},{"location":"library/#processors-distortion","title":"Processors: Distortion","text":"<ul> <li>Resample: Resampler and bit crusher. <code>sample_rate</code> is in Hz, <code>bit_rate</code> is an integer between 0 and 16.</li> <li>SampleAndHold: Samples and holds the input each time a trigger is received on <code>clock</code>.</li> <li>Squiz: Implementation of Dan Stowell's Squiz algorithm, a kind of downsampler.</li> <li>WaveShaper: Applies wave-shaping as described in the WaveShaperBuffer <code>buffer</code>.</li> </ul>"},{"location":"library/#processors-dynamics","title":"Processors: Dynamics","text":"<ul> <li>Compressor: Dynamic range compression, with optional <code>sidechain</code> input. When the input amplitude is above <code>threshold</code>, compresses the amplitude with the given <code>ratio</code>, following the given <code>attack_time</code> and <code>release_time</code> in seconds.</li> <li>Gate: Outputs the input value when it is above the given <code>threshold</code>, otherwise zero.</li> <li>Maximiser: Gain maximiser.</li> <li>RMS: Outputs the root-mean-squared value of the input, in buffers equal to the graph's current buffer size.</li> </ul>"},{"location":"library/#processors-filters","title":"Processors: Filters","text":"<ul> <li>BiquadFilter: Biquad filter. filter_type can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. Not recommended for real-time modulation; for this, use SVFilter.</li> <li>DCFilter: Remove low-frequency and DC content from a signal.</li> <li>EQ: Three-band EQ.</li> <li>MoogVCF: Simulation of the Moog ladder low-pass filter. <code>cutoff</code> sets the cutoff frequency; <code>resonance</code> should typically be between 0..1.</li> <li>SVFilter: State variable filter. <code>filter_type</code> can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. <code>resonance</code> should be between <code>[0..1]</code>.</li> </ul>"},{"location":"library/#processors-panning","title":"Processors: Panning","text":"<ul> <li>AzimuthPanner: Pan input around an equally-spaced ring of <code>num_channels</code> speakers. <code>pan</code> is the pan position from -1..+1, where 0 = centre front. <code>width</code> is the source's width, where 1.0 spans exactly between an adjacent pair of channels.</li> <li>ChannelPanner: Pan the input between a linear series of channels, where <code>pan</code> 0 = channel 0, 1 = channel 1, etc. No wrapping is applied.</li> <li>SpatialPanner: Implements a spatial panning algorithm, applied to a given SpatialEnvironment. Currently, only DBAP is supported.</li> <li>StereoBalance: Takes a stereo input and rebalances it, where <code>balance</code> of <code>0</code> is unchanged, <code>-1</code> is hard left, and <code>1</code> is hard right.</li> <li>StereoPanner: Pans a mono input to a stereo output. <code>pan</code> should be between -1 (hard left) to +1 (hard right), with 0 = centre.</li> <li>StereoWidth: Reduces the width of a stereo signal. When <code>width</code> = 1, input is unchanged. When <code>width</code> = 0, outputs a pair of identical channels both containing L+R.</li> </ul>"},{"location":"library/#sequencing","title":"Sequencing","text":"<ul> <li>ClockDivider: When given a <code>clock</code> input (e.g., an Impulse), divides the clock by the given <code>factor</code>. factor must be an integer greater than or equal to 1.</li> <li>Counter: Count upwards from <code>min</code> to <code>max</code>, driven by <code>clock</code>.</li> <li>Euclidean: Euclidean rhythm as described by Toussaint, with <code>sequence_length</code> (n) and <code>num_events</code> (k), driven by <code>clock</code>.</li> <li>FlipFlop: Flips from 0/1 on each <code>clock</code>.</li> <li>ImpulseSequence: Each time a <code>clock</code> or trigger is received, outputs the next value in <code>sequence</code>. At all other times, outputs zero.</li> <li>Index: Outputs the value in <code>list</code> corresponding to <code>index</code>.</li> <li>Latch: Initially outputs 0. When a trigger is received at <code>set</code>, outputs 1. When a trigger is subsequently received at <code>reset</code>, outputs 0, until the next <code>set</code>.</li> <li>Sequence: Outputs the elements in <code>sequence</code>, incrementing position on each <code>clock</code>.</li> <li>TriggerMult: Distribute any triggers to all output nodes.</li> <li>TriggerRoundRobin: Relay trigger() events to a single node from the list of connected outputs, with <code>direction</code> determining the direction: 1 (or above) = move forwards by N, -1 = move backwards by N, 0 = stationary.</li> </ul>"},{"location":"library/#stochastic","title":"Stochastic","text":"<ul> <li>Logistic: Logistic noise.</li> <li>PinkNoise: Pink noise, with specified low/high cutoffs.</li> <li>RandomBrownian: Outputs Brownian noise between min/max, with a mean change of delta between samples. If a clock is passed, only generates a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomChoice: Pick a random value from the given array. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomCoin: Flip a coin with the given probability. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomExponentialDist: Generate an random value following the exponential distribution. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomExponential: Generate an random exponential value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomGaussian: Generate an random Gaussian value, with given mean and sigma. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomImpulseSequence: Generates a random sequence of 0/1 bits with the given length, and the given probability each each bit = 1. The position of the sequence is incremented on each clock signal. explore and generate are trigger inputs which cause the sequence to mutate and re-generate respectively.</li> <li>RandomImpulse: Generate random impulses at the given frequency, with either uniform or poisson distribution.</li> <li>RandomUniform: Generates a uniformly random value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>WhiteNoise: Generates whitenoise between min/max. If frequency is zero, generates at audio rate. For frequencies lower than audio rate, interpolate applies linear interpolation between values, and random_interval specifies whether new random values should be equally-spaced or randomly-spaced.</li> </ul>"},{"location":"library/analysis/","title":"Analysis","text":"<p>Reference library &gt; Analysis</p>"},{"location":"library/analysis/#analysis","title":"Analysis","text":"<ul> <li>CrossCorrelate: Outputs the cross-correlation of the input signal with the given buffer. If hop_size is zero, calculates the cross-correlation every sample.</li> <li>NearestNeighbour: Nearest Neighbour.</li> <li>OnsetDetector: Simple time-domain onset detector: outputs an impulse when an onset is detected in the input.</li> <li>VampAnalysis: Feature extraction using the Vamp plugin toolkit.</li> </ul>"},{"location":"library/analysis/crosscorrelate/","title":"CrossCorrelate node documentation","text":"<p>Reference library &gt; Analysis &gt; CrossCorrelate</p>"},{"location":"library/analysis/crosscorrelate/#crosscorrelate","title":"CrossCorrelate","text":"<pre><code>CrossCorrelate(input=None, buffer=None, hop_size=0)\n</code></pre> <p>Outputs the cross-correlation of the input signal with the given buffer. If hop_size is zero, calculates the cross-correlation every sample.</p>"},{"location":"library/analysis/nearestneighbour/","title":"NearestNeighbour node documentation","text":"<p>Reference library &gt; Analysis &gt; NearestNeighbour</p>"},{"location":"library/analysis/nearestneighbour/#nearestneighbour","title":"NearestNeighbour","text":"<pre><code>NearestNeighbour(buffer=None, target=0.0)\n</code></pre> <p>Nearest Neighbour.</p>"},{"location":"library/analysis/onsetdetector/","title":"OnsetDetector node documentation","text":"<p>Reference library &gt; Analysis &gt; OnsetDetector</p>"},{"location":"library/analysis/onsetdetector/#onsetdetector","title":"OnsetDetector","text":"<pre><code>OnsetDetector(input=0.0, threshold=2.0, min_interval=0.1)\n</code></pre> <p>Simple time-domain onset detector: outputs an impulse when an onset is detected in the input. </p> <p>Maintains short-time and long-time averages. An onset is registered when the short-time average is threshold x the long-time average. min_interval is the minimum interval between onsets, in seconds.</p>"},{"location":"library/analysis/vampanalysis/","title":"VampAnalysis node documentation","text":"<p>Reference library &gt; Analysis &gt; VampAnalysis</p>"},{"location":"library/analysis/vampanalysis/#vampanalysis","title":"VampAnalysis","text":"<pre><code>VampAnalysis(input=0.0, plugin_id=\"vamp-example-plugins:spectralcentroid:linearcentroid\")\n</code></pre> <p>Feature extraction using the Vamp plugin toolkit.</p>"},{"location":"library/buffer/","title":"Buffer","text":"<p>Reference library &gt; Buffer</p>"},{"location":"library/buffer/#buffer","title":"Buffer","text":"<ul> <li>BeatCutter: Cuts a buffer into segment_count segments, and stutters/jumps with the given probabilities.</li> <li>BufferLooper: Read and write from a buffer concurrently, with controllable overdub.</li> <li>BufferPlayer: Plays the contents of the given buffer. <code>start_time</code>/<code>end_time</code> are in seconds. When a <code>clock</code> signal is received, rewinds to the <code>start_time</code>.</li> <li>BufferRecorder: Records the input to a buffer. feedback controls overdub.</li> <li>FeedbackBufferReader: Counterpart to FeedbackBufferWriter.</li> <li>FeedbackBufferWriter: Counterpart to FeedbackBufferReader.</li> <li>HistoryBufferWriter: Writes a rolling history buffer of a given duration. At a given moment in time, the contents of the buffer will be equal to the past N seconds of the audio generated by <code>input</code>.</li> <li>SegmentPlayer: Trigger segments of <code>buffer</code> at the given list of <code>onsets</code> positions, in seconds.</li> </ul>"},{"location":"library/buffer/beatcutter/","title":"BeatCutter node documentation","text":"<p>Reference library &gt; Buffer &gt; BeatCutter</p>"},{"location":"library/buffer/beatcutter/#beatcutter","title":"BeatCutter","text":"<pre><code>BeatCutter(buffer=None, segment_count=8, stutter_probability=0.0, stutter_count=1, jump_probability=0.0, duty_cycle=1.0, rate=1.0, segment_rate=1.0)\n</code></pre> <p>Cuts a buffer into segment_count segments, and stutters/jumps with the given probabilities.</p>"},{"location":"library/buffer/bufferlooper/","title":"BufferLooper node documentation","text":"<p>Reference library &gt; Buffer &gt; BufferLooper</p>"},{"location":"library/buffer/bufferlooper/#bufferlooper","title":"BufferLooper","text":"<pre><code>BufferLooper(buffer=None, input=0.0, feedback=0.0, loop_playback=0, loop_record=0, start_time=None, end_time=None, looper_level=1.0, playthrough_level=0.0)\n</code></pre> <p>Read and write from a buffer concurrently, with controllable overdub.</p>"},{"location":"library/buffer/bufferplayer/","title":"BufferPlayer node documentation","text":"<p>Reference library &gt; Buffer &gt; BufferPlayer</p>"},{"location":"library/buffer/bufferplayer/#bufferplayer","title":"BufferPlayer","text":"<pre><code>BufferPlayer(buffer=None, rate=1.0, loop=0, start_time=None, end_time=None, clock=None)\n</code></pre> <p>Plays the contents of the given buffer. <code>start_time</code>/<code>end_time</code> are in seconds. When a <code>clock</code> signal is received, rewinds to the <code>start_time</code>. </p> <p>Set <code>clock</code> to <code>0</code> to prevent the buffer from being triggered immediately.</p>"},{"location":"library/buffer/bufferrecorder/","title":"BufferRecorder node documentation","text":"<p>Reference library &gt; Buffer &gt; BufferRecorder</p>"},{"location":"library/buffer/bufferrecorder/#bufferrecorder","title":"BufferRecorder","text":"<pre><code>BufferRecorder(buffer=None, input=0.0, feedback=0.0, loop=false)\n</code></pre> <p>Records the input to a buffer. feedback controls overdub.</p>"},{"location":"library/buffer/feedbackbufferreader/","title":"FeedbackBufferReader node documentation","text":"<p>Reference library &gt; Buffer &gt; FeedbackBufferReader</p>"},{"location":"library/buffer/feedbackbufferreader/#feedbackbufferreader","title":"FeedbackBufferReader","text":"<pre><code>FeedbackBufferReader(buffer=None)\n</code></pre> <p>Counterpart to FeedbackBufferWriter.</p>"},{"location":"library/buffer/feedbackbufferwriter/","title":"FeedbackBufferWriter node documentation","text":"<p>Reference library &gt; Buffer &gt; FeedbackBufferWriter</p>"},{"location":"library/buffer/feedbackbufferwriter/#feedbackbufferwriter","title":"FeedbackBufferWriter","text":"<pre><code>FeedbackBufferWriter(buffer=None, input=0.0, delay_time=0.1)\n</code></pre> <p>Counterpart to FeedbackBufferReader.</p>"},{"location":"library/buffer/grainsegments/","title":"GrainSegments node documentation","text":"<p>Reference library &gt; Buffer &gt; GrainSegments</p>"},{"location":"library/buffer/grainsegments/#grainsegments","title":"GrainSegments","text":"<pre><code>GrainSegments(buffer=None, clock=0, target=0, offsets={}, values={}, durations={})\n</code></pre> <p>GrainSegments</p>"},{"location":"library/buffer/granulation/","title":"Index","text":"<p>Reference library &gt; Buffer: Granulation</p>"},{"location":"library/buffer/granulation/#buffer-granulation","title":"Buffer: Granulation","text":"<ul> <li>SegmentedGranulator: Segmented Granulator.</li> <li>Granulator: Granulator. Generates a grain from the given buffer each time a trigger is received on the <code>clock</code> input. Each new grain uses the given <code>duration</code>, <code>amplitude</code>, <code>pan</code> and <code>rate</code> values presented at each input at the moment the grain is created. The input buffer can be mono or stereo. If <code>wrap</code> is true, grain playback can wrap around the end/start of the buffer.</li> </ul>"},{"location":"library/buffer/granulation/granulator/","title":"Granulator node documentation","text":"<p>Reference library &gt; Buffer: Granulation &gt; Granulator</p>"},{"location":"library/buffer/granulation/granulator/#granulator","title":"Granulator","text":"<pre><code>Granulator(buffer=None, clock=0, pos=0, duration=0.1, amplitude=1.0, pan=0.0, rate=1.0, max_grains=2048, wrap=false)\n</code></pre> <p>Granulator. Generates a grain from the given buffer each time a trigger is received on the <code>clock</code> input. Each new grain uses the given <code>duration</code>, <code>amplitude</code>, <code>pan</code> and <code>rate</code> values presented at each input at the moment the grain is created. The input buffer can be mono or stereo. If <code>wrap</code> is true, grain playback can wrap around the end/start of the buffer.</p>"},{"location":"library/buffer/granulation/segmentedgranulator/","title":"SegmentedGranulator node documentation","text":"<p>Reference library &gt; Buffer: Granulation &gt; SegmentedGranulator</p>"},{"location":"library/buffer/granulation/segmentedgranulator/#segmentedgranulator","title":"SegmentedGranulator","text":"<pre><code>SegmentedGranulator(buffer=None, onset_times={}, durations={}, index=0.0, rate=1.0, clock=0, max_grains=2048)\n</code></pre> <p>Segmented Granulator.</p>"},{"location":"library/buffer/granulator/","title":"Granulator node documentation","text":"<p>Reference library &gt; Buffer &gt; Granulator</p>"},{"location":"library/buffer/granulator/#granulator","title":"Granulator","text":"<pre><code>Granulator(buffer=None, clock=0, pos=0, duration=0.1, pan=0.0, rate=1.0, max_grains=2048)\n</code></pre> <p>Granulator. Generates a grain from the given buffer each time a clock signal is received, with the given duration/rate/pan parameters. The input buffer can be mono or stereo.</p>"},{"location":"library/buffer/historybufferwriter/","title":"HistoryBufferWriter node documentation","text":"<p>Reference library &gt; Buffer &gt; HistoryBufferWriter</p>"},{"location":"library/buffer/historybufferwriter/#historybufferwriter","title":"HistoryBufferWriter","text":"<pre><code>HistoryBufferWriter(buffer=None, input=0.0, downsample=1)\n</code></pre> <p>Writes a rolling history buffer of a given duration. At a given moment in time, the contents of the buffer will be equal to the past N seconds of the audio generated by <code>input</code>. </p> <p>This is useful for (e.g.) a visual display of a rolling waveform or LFO window. <code>downsample</code> can be used to downsample the input; for example, with <code>downsample</code> of 10, a 1-second buffer can be used to display 10 seconds of historical audio.</p>"},{"location":"library/buffer/segmentplayer/","title":"SegmentPlayer node documentation","text":"<p>Reference library &gt; Buffer &gt; SegmentPlayer</p>"},{"location":"library/buffer/segmentplayer/#segmentplayer","title":"SegmentPlayer","text":"<pre><code>SegmentPlayer(buffer=None, onsets={}, index=None, rate=1.0, start_offset=None, clock=None, continue_after_segment=0)\n</code></pre> <p>Trigger segments of <code>buffer</code> at the given list of <code>onsets</code> positions, in seconds. </p> <p><code>index</code> determines the index of the onset to play back at, which can also be passed as an argument to trigger(). <code>rate</code> determines the playback rate, and <code>clock</code> can be used to retrigger based on the output of another Node. If <code>continue_after_segment</code> is non-zero, playback will continue after the subsequent onset.</p>"},{"location":"library/control/","title":"Control","text":"<p>Reference library &gt; Control</p>"},{"location":"library/control/#control","title":"Control","text":"<ul> <li>MouseX: Outputs the normalised cursor X position, from 0 to 1. Currently only supported on macOS.</li> <li>MouseY: Outputs the normalised cursor Y position, from 0 to 1. Currently only supported on macOS.</li> <li>MouseDown: Outputs 1 if the left mouse button is down, 0 otherwise. Currently only supported on macOS.</li> </ul>"},{"location":"library/control/mousedown/","title":"MouseDown node documentation","text":"<p>Reference library &gt; Control &gt; MouseDown</p>"},{"location":"library/control/mousedown/#mousedown","title":"MouseDown","text":"<pre><code>MouseDown(button_index=0)\n</code></pre> <p>Outputs 1 if the left mouse button is down, 0 otherwise. Currently only supported on macOS.</p>"},{"location":"library/control/mousedown/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# When the left mouse button is clicked, as detected by MouseDown(), an LFO is \n# applied to the oscillator's frequency.\n#-------------------------------------------------------------------------------\nlfo = SineLFO(5, 100, 600)\nfrequency = If(MouseDown(), lfo, 100)\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# A simple wobbling synthesiser controlled using the mouse. When the mouse is \n# clicked, as detected by MouseDown(), an LFO is activated and affects the \n# oscillator's frequency. MouseX position changes the rate of the LFO. MouseY \n# position changes the upper frequency limit, affecting pitch.\n#-------------------------------------------------------------------------------\nrate = MouseX() * 10\nupper_limit = MouseY() * 1500\nlfo = SineLFO(rate, 100, upper_limit)\nfrequency = If(MouseDown(), lfo, 100)\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre>"},{"location":"library/control/mousex/","title":"MouseX node documentation","text":"<p>Reference library &gt; Control &gt; MouseX</p>"},{"location":"library/control/mousex/#mousex","title":"MouseX","text":"<pre><code>MouseX()\n</code></pre> <p>Outputs the normalised cursor X position, from 0 to 1. Currently only supported on macOS.</p>"},{"location":"library/control/mousex/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using the MouseX position to change the rate of an LFO, which is modulating an\n# oscillator's frequency.\n#-------------------------------------------------------------------------------\nlfo_rate = MouseX() * 10\nfrequency = SineLFO(lfo_rate, 100, 600)\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# A simple wobbling synthesiser controlled using the mouse. When the mouse is \n# clicked, as detected by MouseDown(), an LFO is activated and affects the \n# oscillator's frequency. MouseX position changes the rate of the LFO. MouseY \n# position changes the upper frequency limit, affecting pitch.\n#-------------------------------------------------------------------------------\nrate = MouseX() * 10\nupper_limit = MouseY() * 1500\nlfo = SineLFO(rate, 100, upper_limit)\nfrequency = If(MouseDown(), lfo, 100)\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre>"},{"location":"library/control/mousey/","title":"MouseY node documentation","text":"<p>Reference library &gt; Control &gt; MouseY</p>"},{"location":"library/control/mousey/#mousey","title":"MouseY","text":"<pre><code>MouseY()\n</code></pre> <p>Outputs the normalised cursor Y position, from 0 to 1. Currently only supported on macOS.</p>"},{"location":"library/control/mousey/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using the MouseY position to change the frequency of an oscillator.\n#-------------------------------------------------------------------------------\nfrequency = MouseY() * 1000\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# A simple wobbling synthesiser controlled using the mouse. When the mouse is \n# clicked, as detected by MouseDown(), an LFO is activated and affects the \n# oscillator's frequency. MouseX position changes the rate of the LFO. MouseY \n# position changes the upper frequency limit, affecting pitch.\n#-------------------------------------------------------------------------------\nrate = MouseX() * 10\nupper_limit = MouseY() * 1500\nlfo = SineLFO(rate, 100, upper_limit)\nfrequency = If(MouseDown(), lfo, 100)\nosc = TriangleOscillator(frequency)\nosc.play()\n</code></pre>"},{"location":"library/envelope/","title":"Envelope","text":"<p>Reference library &gt; Envelope</p>"},{"location":"library/envelope/#envelope","title":"Envelope","text":"<ul> <li>Accumulator: Accumulator with decay.</li> <li>ADSREnvelope: Attack-decay-sustain-release envelope. Sustain portion is held until gate is zero.</li> <li>ASREnvelope: Attack-sustain-release envelope.</li> <li>DetectSilence: Detects blocks of silence below the threshold value. Used as an auto-free node to terminate a Patch after processing is complete.</li> <li>Envelope: Generic envelope constructor, given an array of levels, times and curves.</li> <li>Line: Line segment with the given start/end values, and duration (in seconds). If loop is true, repeats indefinitely. Retriggers on a clock signal.</li> <li>RectangularEnvelope: Rectangular envelope with the given sustain duration.</li> </ul>"},{"location":"library/envelope/accumulator/","title":"Accumulator node documentation","text":"<p>Reference library &gt; Envelope &gt; Accumulator</p>"},{"location":"library/envelope/accumulator/#accumulator","title":"Accumulator","text":"<pre><code>Accumulator(strike_force=0.5, decay_coefficient=0.9999, trigger=None)\n</code></pre> <p>Accumulator with decay.</p>"},{"location":"library/envelope/adsrenvelope/","title":"ADSREnvelope node documentation","text":"<p>Reference library &gt; Envelope &gt; ADSREnvelope</p>"},{"location":"library/envelope/adsrenvelope/#adsrenvelope","title":"ADSREnvelope","text":"<pre><code>ADSREnvelope(attack=0.1, decay=0.1, sustain=0.5, release=0.1, gate=0)\n</code></pre> <p>Attack-decay-sustain-release envelope. Sustain portion is held until gate is zero.</p>"},{"location":"library/envelope/asrenvelope/","title":"ASREnvelope node documentation","text":"<p>Reference library &gt; Envelope &gt; ASREnvelope</p>"},{"location":"library/envelope/asrenvelope/#asrenvelope","title":"ASREnvelope","text":"<pre><code>ASREnvelope(attack=0.1, sustain=0.5, release=0.1, curve=1.0, clock=None)\n</code></pre> <p>Attack-sustain-release envelope.</p>"},{"location":"library/envelope/asrenvelope/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using an ASR Envelope to shape a square wave oscillator\n#-------------------------------------------------------------------------------\nosc = SquareOscillator(500)\nenvelope = ASREnvelope(0.1, 0.0, 0.5)\noutput = osc * envelope\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using ASREnvelope to shape the sound of an oscillator over time.\n# The Line node generates a continuously-changing value which we use as the \n# release time.\n#-------------------------------------------------------------------------------\nclock = Impulse(8.0)\nCMaj7 = [ 60, 64, 67, 71, 74, 76 ] * 8\nFMaj9 = [ 65, 69, 72, 76, 77, 81 ] * 8\narpeggios = CMaj7 + FMaj9\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = TriangleOscillator(frequency)\nrelease = Line(0.1, 0.5, 6, True)\nenvelope = ASREnvelope(attack=0.0, \n                       sustain=0.0, \n                       release=release, \n                       curve=1.0, \n                       clock=clock)\nvoice = oscillator * envelope\n\npan = SineLFO(0.1667, -1.0, 1.0)\noutput = StereoPanner(voice, pan)\noutput.play()\n</code></pre>"},{"location":"library/envelope/detectsilence/","title":"DetectSilence node documentation","text":"<p>Reference library &gt; Envelope &gt; DetectSilence</p>"},{"location":"library/envelope/detectsilence/#detectsilence","title":"DetectSilence","text":"<pre><code>DetectSilence(input=None, threshold=0.00001)\n</code></pre> <p>Detects blocks of silence below the threshold value. Used as an auto-free node to terminate a Patch after processing is complete.</p>"},{"location":"library/envelope/envelope/","title":"Envelope node documentation","text":"<p>Reference library &gt; Envelope &gt; Envelope</p>"},{"location":"library/envelope/envelope/#envelope","title":"Envelope","text":"<pre><code>Envelope(levels=std::vector&lt;NodeRef&gt; ( ), times=std::vector&lt;NodeRef&gt; ( ), curves=std::vector&lt;NodeRef&gt; ( ), clock=None, loop=false)\n</code></pre> <p>Generic envelope constructor, given an array of levels, times and curves.</p>"},{"location":"library/envelope/line/","title":"Line node documentation","text":"<p>Reference library &gt; Envelope &gt; Line</p>"},{"location":"library/envelope/line/#line","title":"Line","text":"<pre><code>Line(start=0.0, end=1.0, time=1.0, loop=0, clock=None)\n</code></pre> <p>Line segment with the given start/end values, and duration (in seconds). If loop is true, repeats indefinitely. Retriggers on a clock signal.</p>"},{"location":"library/envelope/line/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using a line to control the gain of an oscillator, emulating a sidechain \n# ducking effect.\n#-------------------------------------------------------------------------------\nclock = Impulse(frequency=1.0)\nline = Line(0.0, 0.5, 0.5, False, clock)\nosc = SawOscillator(200)\noutput = StereoPanner(osc * line)\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using Line to repeatedly alter the release value of an envelope applied to the\n# main synth voice, in time with the music.\n#-------------------------------------------------------------------------------\nclock = Impulse(8.0)\nCMaj7 = [ 60, 64, 67, 71, 74, 76 ] * 8\nFMaj9 = [ 65, 69, 72, 76, 77, 81 ] * 8\narpeggios = CMaj7 + FMaj9\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = TriangleOscillator(frequency)\nrelease = Line(0.1, 0.5, 6, True)\nenvelope = ASREnvelope(0.0, 0.0, release, 1.0, clock)\nvoice = oscillator * envelope\n\npan = SineLFO(0.1667, -1.0, 1.0)\noutput = StereoPanner(voice, pan)\noutput.play()\n</code></pre>"},{"location":"library/envelope/rectangularenvelope/","title":"RectangularEnvelope node documentation","text":"<p>Reference library &gt; Envelope &gt; RectangularEnvelope</p>"},{"location":"library/envelope/rectangularenvelope/#rectangularenvelope","title":"RectangularEnvelope","text":"<pre><code>RectangularEnvelope(sustain_duration=1.0, clock=None)\n</code></pre> <p>Rectangular envelope with the given sustain duration.</p>"},{"location":"library/fft/","title":"FFT","text":"<p>Reference library &gt; FFT</p>"},{"location":"library/fft/#fft","title":"FFT","text":"<ul> <li>FFTContinuousPhaseVocoder: Continuous phase vocoder. Requires an FFT* input.</li> <li>FFTConvolve: Frequency-domain convolution, using overlap-add. Useful for convolution reverb, with the input buffer containing an impulse response. Requires an FFT* input.</li> <li>FFTBufferPlayer: FFTBufferPlayer. Plays from a buffer of audio spectra in mag/phase format.</li> <li>FFTContrast: FFT Contrast. Requires an FFT* input.</li> <li>FFTCrossFade: FFT FFTCrossFade. Requires two FFT* inputs.</li> <li>FFTLFO: FFT LFO. Requires an FFT* input.</li> <li>FFTMagnitudePhaseArray: Fixed mag/phase array.</li> <li>FFTRandomPhase: Randomise phase values.</li> <li>FFTScaleMagnitudes: Randomise phase values.</li> <li>FFTTransform: Transforms the FFT magnitude spectrum in the X axis. Requires an FFT* input.</li> <li>FFT: Fast Fourier Transform. Takes a time-domain input, and generates a frequency-domain (FFT) output.</li> <li>FFTFindPeaks: Find peaks in the FFT magnitude spectrum. Requires an FFT* input.</li> <li>IFFT: Inverse Fast Fourier Transform. Requires an FFT* input, generates a time-domain output.</li> <li>FFTLPF: FFT-based brick wall low pass filter. Requires an FFT* input.</li> <li>FFTNoiseGate: FFT-based noise gate. Requires an FFT* input.</li> <li>FFTPhaseVocoder: Phase vocoder. Requires an FFT* input.</li> <li>FFTTonality: Tonality filter. Requires an FFT* input.</li> <li>FFTZeroPhase: Remove phase information from a frequency-domain input. Requires an FFT* input.</li> </ul>"},{"location":"library/fft/fft/","title":"FFT node documentation","text":"<p>Reference library &gt; FFT &gt; FFT</p>"},{"location":"library/fft/fft/#fft","title":"FFT","text":"<pre><code>FFT(input=0.0, fft_size=SIGNALFLOW_DEFAULT_FFT_SIZE, hop_size=SIGNALFLOW_DEFAULT_FFT_HOP_SIZE, window_size=0, do_window=true)\n</code></pre> <p>Fast Fourier Transform. Takes a time-domain input, and generates a frequency-domain (FFT) output.</p>"},{"location":"library/fft/fftbufferplayer/","title":"FFTBufferPlayer node documentation","text":"<p>Reference library &gt; FFT &gt; FFTBufferPlayer</p>"},{"location":"library/fft/fftbufferplayer/#fftbufferplayer","title":"FFTBufferPlayer","text":"<pre><code>FFTBufferPlayer(buffer=None, rate=1.0)\n</code></pre> <p>FFTBufferPlayer. Plays from a buffer of audio spectra in mag/phase format.</p>"},{"location":"library/fft/fftcontinuousphasevocoder/","title":"FFTContinuousPhaseVocoder node documentation","text":"<p>Reference library &gt; FFT &gt; FFTContinuousPhaseVocoder</p>"},{"location":"library/fft/fftcontinuousphasevocoder/#fftcontinuousphasevocoder","title":"FFTContinuousPhaseVocoder","text":"<pre><code>FFTContinuousPhaseVocoder(input=None, rate=1.0)\n</code></pre> <p>Continuous phase vocoder. Requires an FFT* input.</p>"},{"location":"library/fft/fftcontrast/","title":"FFTContrast node documentation","text":"<p>Reference library &gt; FFT &gt; FFTContrast</p>"},{"location":"library/fft/fftcontrast/#fftcontrast","title":"FFTContrast","text":"<pre><code>FFTContrast(input=0, contrast=1)\n</code></pre> <p>FFT Contrast. Requires an FFT* input.</p>"},{"location":"library/fft/fftconvolve/","title":"FFTConvolve node documentation","text":"<p>Reference library &gt; FFT &gt; FFTConvolve</p>"},{"location":"library/fft/fftconvolve/#fftconvolve","title":"FFTConvolve","text":"<pre><code>FFTConvolve(input=None, buffer=None)\n</code></pre> <p>Frequency-domain convolution, using overlap-add. Useful for convolution reverb, with the input buffer containing an impulse response. Requires an FFT* input.</p>"},{"location":"library/fft/fftcrossfade/","title":"FFTCrossFade node documentation","text":"<p>Reference library &gt; FFT &gt; FFTCrossFade</p>"},{"location":"library/fft/fftcrossfade/#fftcrossfade","title":"FFTCrossFade","text":"<pre><code>FFTCrossFade(inputA=0, inputB=0, crossfade=0.0)\n</code></pre> <p>FFT FFTCrossFade. Requires two FFT* inputs.</p>"},{"location":"library/fft/fftfindpeaks/","title":"FFTFindPeaks node documentation","text":"<p>Reference library &gt; FFT &gt; FFTFindPeaks</p>"},{"location":"library/fft/fftfindpeaks/#fftfindpeaks","title":"FFTFindPeaks","text":"<pre><code>FFTFindPeaks(input=0, prominence=1, threshold=0.000001, count=SIGNALFLOW_MAX_CHANNELS, interpolate=true)\n</code></pre> <p>Find peaks in the FFT magnitude spectrum. Requires an FFT* input.</p>"},{"location":"library/fft/fftflipspectrum/","title":"FFTFlipSpectrum node documentation","text":"<p>Reference library &gt; FFT &gt; FFTFlipSpectrum</p>"},{"location":"library/fft/fftflipspectrum/#fftflipspectrum","title":"FFTFlipSpectrum","text":"<pre><code>FFTFlipSpectrum(input=0, flip=0, rotate=0)\n</code></pre> <p>Flips the FFT magnitude spectrum in the X axis. Requires an FFT* input.</p>"},{"location":"library/fft/fftlfo/","title":"FFTLFO node documentation","text":"<p>Reference library &gt; FFT &gt; FFTLFO</p>"},{"location":"library/fft/fftlfo/#fftlfo","title":"FFTLFO","text":"<pre><code>FFTLFO(input=0, frequency=1.0, spectral_cycles=1.0)\n</code></pre> <p>FFT LFO. Requires an FFT* input.</p>"},{"location":"library/fft/fftlpf/","title":"FFTLPF node documentation","text":"<p>Reference library &gt; FFT &gt; FFTLPF</p>"},{"location":"library/fft/fftlpf/#fftlpf","title":"FFTLPF","text":"<pre><code>FFTLPF(input=0, frequency=2000)\n</code></pre> <p>FFT-based brick wall low pass filter. Requires an FFT* input.</p>"},{"location":"library/fft/fftmagnitudephasearray/","title":"FFTMagnitudePhaseArray node documentation","text":"<p>Reference library &gt; FFT &gt; FFTMagnitudePhaseArray</p>"},{"location":"library/fft/fftmagnitudephasearray/#fftmagnitudephasearray","title":"FFTMagnitudePhaseArray","text":"<pre><code>FFTMagnitudePhaseArray(input=0, magnitudes={}, phases={})\n</code></pre> <p>Fixed mag/phase array.</p>"},{"location":"library/fft/fftnoisegate/","title":"FFTNoiseGate node documentation","text":"<p>Reference library &gt; FFT &gt; FFTNoiseGate</p>"},{"location":"library/fft/fftnoisegate/#fftnoisegate","title":"FFTNoiseGate","text":"<pre><code>FFTNoiseGate(input=0, threshold=0.5, invert=0.0)\n</code></pre> <p>FFT-based noise gate. Requires an FFT* input.</p>"},{"location":"library/fft/fftphasevocoder/","title":"FFTPhaseVocoder node documentation","text":"<p>Reference library &gt; FFT &gt; FFTPhaseVocoder</p>"},{"location":"library/fft/fftphasevocoder/#fftphasevocoder","title":"FFTPhaseVocoder","text":"<pre><code>FFTPhaseVocoder(input=None)\n</code></pre> <p>Phase vocoder. Requires an FFT* input.</p>"},{"location":"library/fft/fftrandomphase/","title":"FFTRandomPhase node documentation","text":"<p>Reference library &gt; FFT &gt; FFTRandomPhase</p>"},{"location":"library/fft/fftrandomphase/#fftrandomphase","title":"FFTRandomPhase","text":"<pre><code>FFTRandomPhase(input=0, level=1.0)\n</code></pre> <p>Randomise phase values.</p>"},{"location":"library/fft/fftscalemagnitudes/","title":"FFTScaleMagnitudes node documentation","text":"<p>Reference library &gt; FFT &gt; FFTScaleMagnitudes</p>"},{"location":"library/fft/fftscalemagnitudes/#fftscalemagnitudes","title":"FFTScaleMagnitudes","text":"<pre><code>FFTScaleMagnitudes(input=0, scale={})\n</code></pre> <p>Randomise phase values.</p>"},{"location":"library/fft/ffttonality/","title":"FFTTonality node documentation","text":"<p>Reference library &gt; FFT &gt; FFTTonality</p>"},{"location":"library/fft/ffttonality/#ffttonality","title":"FFTTonality","text":"<pre><code>FFTTonality(input=0, level=0.5, smoothing=0.9)\n</code></pre> <p>Tonality filter. Requires an FFT* input.</p>"},{"location":"library/fft/ffttransform/","title":"FFTTransform node documentation","text":"<p>Reference library &gt; FFT &gt; FFTTransform</p>"},{"location":"library/fft/ffttransform/#ffttransform","title":"FFTTransform","text":"<pre><code>FFTTransform(input=0, flip=0, rotate=0)\n</code></pre> <p>Transforms the FFT magnitude spectrum in the X axis. Requires an FFT* input.</p>"},{"location":"library/fft/fftzerophase/","title":"FFTZeroPhase node documentation","text":"<p>Reference library &gt; FFT &gt; FFTZeroPhase</p>"},{"location":"library/fft/fftzerophase/#fftzerophase","title":"FFTZeroPhase","text":"<pre><code>FFTZeroPhase(input=0)\n</code></pre> <p>Remove phase information from a frequency-domain input. Requires an FFT* input.</p>"},{"location":"library/fft/ifft/","title":"IFFT node documentation","text":"<p>Reference library &gt; FFT &gt; IFFT</p>"},{"location":"library/fft/ifft/#ifft","title":"IFFT","text":"<pre><code>IFFT(input=None, do_window=false)\n</code></pre> <p>Inverse Fast Fourier Transform. Requires an FFT* input, generates a time-domain output.</p>"},{"location":"library/operators/","title":"Operators","text":"<p>Reference library &gt; Operators</p>"},{"location":"library/operators/#operators","title":"Operators","text":"<ul> <li>Add: Add each sample of a to each sample of b. Can also be written as a + b</li> <li>AmplitudeToDecibels: Map a linear amplitude value to decibels.</li> <li>DecibelsToAmplitude: DecibelsToAmplitude</li> <li>Bus: Bus is a node with a fixed number of input channels and arbitrary number of inputs, used to aggregate multiple sources. It is similar to Sum, but with a defined channel count that does not adapt to its inputs.</li> <li>ChannelArray: Takes an array of inputs and spreads them across multiple channels of output.</li> <li>ChannelCrossfade: Given a multichannel input, crossfades between channels based on the given position within the virtual array, producing a single-channel output.</li> <li>ChannelMixer: Downmix a multichannel input to a lower-channel output. If num_channels is greater than one, spreads the input channels across the field. If amplitude_compensation is enabled, scale down the amplitude based on the ratio of input to output channels.</li> <li>ChannelOffset: Offsets the input by a specified number of channels. With an N-channel input and an offset of M, the output will have M+N channels.</li> <li>ChannelSelect: Select a subset of channels from a multichannel input, starting at offset, up to a maximum of maximum, with the given step.</li> <li>Equal: Compares the output of a to the output of b. Outputs 1 when equal, 0 otherwise. Can also be written as a == b</li> <li>NotEqual: Compares the output of a to the output of b. Outputs 0 when equal, 1 otherwise. Can also be written as a != b</li> <li>GreaterThan: Compares the output of a to the output of b. Outputs 1 when a &gt; b, 0 otherwise. Can also be written as a &gt; b</li> <li>GreaterThanOrEqual: Compares the output of a to the output of b. Outputs 1 when a &gt;= b, 0 otherwise. Can also be written as a &gt;= b</li> <li>LessThan: Compares the output of a to the output of b. Outputs 1 when a &lt; b, 0 otherwise. Can also be written as a &lt; b</li> <li>LessThanOrEqual: Compares the output of a to the output of b. Outputs 1 when a &lt;= b, 0 otherwise. Can also be written as a &lt;= b</li> <li>Modulo: Outputs the value of a modulo b, per sample. Supports fractional values. Can also be written as a % b</li> <li>Abs: Outputs the absolute value of a, per sample. Can also be written as abs(a)</li> <li>If: Outputs value_if_true for each non-zero value of a, value_if_false for all other values.</li> <li>Divide: Divide each sample of a by each sample of b. Can also be written as a / b</li> <li>FrequencyToMidiNote: Map a frequency to a MIDI note (where 440Hz = A4 = 69), with floating-point output.</li> <li>MidiNoteToFrequency: Map a MIDI note to a frequency (where 440Hz = A4 = 69), supporting floating-point input.</li> <li>Multiply: Multiply each sample of a by each sample of b. Can also be written as a * b</li> <li>Pow: Outputs a to the power of b, per sample. Can also be written as a ** b</li> <li>RoundToScale: Given a frequency input, generates a frequency output that is rounded to the nearest MIDI note. (TODO: Not very well named)</li> <li>Round: Round the input to the nearest integer value.</li> <li>ScaleLinExp: Scales the input from a linear range (between a and b) to an exponential range (between c and d).</li> <li>ScaleLinLin: Scales the input from a linear range (between a and b) to a linear range (between c and d).</li> <li>SelectInput: Pass through the output of one or more <code>inputs</code>, based on the integer input index specified in <code>index</code>. Unlike <code>ChannelSelect</code>, inputs may be multichannel, and <code>index</code> can be modulated in real time.</li> <li>Subtract: Subtract each sample of b from each sample of a. Can also be written as a - b</li> <li>Sum: Sums the output of all of the input nodes, by sample.</li> <li>TimeShift: TimeShift</li> <li>Sin: Outputs sin(a), per sample.</li> <li>Cos: Outputs cos(a), per sample.</li> <li>Tan: Outputs tan(a), per sample.</li> <li>Tanh: Outputs tanh(a), per sample. Can be used as a soft clipper.</li> </ul>"},{"location":"library/operators/abs/","title":"Abs node documentation","text":"<p>Reference library &gt; Operators &gt; Abs</p>"},{"location":"library/operators/abs/#abs","title":"Abs","text":"<pre><code>Abs(a=0)\n</code></pre> <p>Outputs the absolute value of a, per sample. Can also be written as abs(a)</p>"},{"location":"library/operators/add/","title":"Add node documentation","text":"<p>Reference library &gt; Operators &gt; Add</p>"},{"location":"library/operators/add/#add","title":"Add","text":"<pre><code>Add(a=0, b=0)\n</code></pre> <p>Add each sample of a to each sample of b. Can also be written as a + b</p>"},{"location":"library/operators/amplitudetodecibels/","title":"AmplitudeToDecibels node documentation","text":"<p>Reference library &gt; Operators &gt; AmplitudeToDecibels</p>"},{"location":"library/operators/amplitudetodecibels/#amplitudetodecibels","title":"AmplitudeToDecibels","text":"<pre><code>AmplitudeToDecibels(a=0)\n</code></pre> <p>Map a linear amplitude value to decibels.</p>"},{"location":"library/operators/bus/","title":"Bus node documentation","text":"<p>Reference library &gt; Operators &gt; Bus</p>"},{"location":"library/operators/bus/#bus","title":"Bus","text":"<pre><code>Bus(num_channels=1)\n</code></pre> <p>Bus is a node with a fixed number of input channels and arbitrary number of inputs, used to aggregate multiple sources. It is similar to Sum, but with a defined channel count that does not adapt to its inputs.</p>"},{"location":"library/operators/channelarray/","title":"ChannelArray node documentation","text":"<p>Reference library &gt; Operators &gt; ChannelArray</p>"},{"location":"library/operators/channelarray/#channelarray","title":"ChannelArray","text":"<pre><code>ChannelArray()\n</code></pre> <p>Takes an array of inputs and spreads them across multiple channels of output.</p>"},{"location":"library/operators/channelarray/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using ChannelArray to pan a low tone to the left and a high tone to the right.\n#-------------------------------------------------------------------------------\nlow = TriangleOscillator(220)\nhigh = TriangleOscillator(660)\npanned = ChannelArray([low, high]) * 0.3\npanned.play()\n</code></pre>"},{"location":"library/operators/channelcrossfade/","title":"ChannelCrossfade node documentation","text":"<p>Reference library &gt; Operators &gt; ChannelCrossfade</p>"},{"location":"library/operators/channelcrossfade/#channelcrossfade","title":"ChannelCrossfade","text":"<pre><code>ChannelCrossfade(input=None, index=None, num_output_channels=1)\n</code></pre> <p>Given a multichannel input, crossfades between channels based on the given position within the virtual array, producing a single-channel output.</p>"},{"location":"library/operators/channelmixer/","title":"ChannelMixer node documentation","text":"<p>Reference library &gt; Operators &gt; ChannelMixer</p>"},{"location":"library/operators/channelmixer/#channelmixer","title":"ChannelMixer","text":"<pre><code>ChannelMixer(num_channels=1, input=0, amplitude_compensation=true)\n</code></pre> <p>Downmix a multichannel input to a lower-channel output. If num_channels is greater than one, spreads the input channels across the field. If amplitude_compensation is enabled, scale down the amplitude based on the ratio of input to output channels.</p>"},{"location":"library/operators/channeloffset/","title":"ChannelOffset node documentation","text":"<p>Reference library &gt; Operators &gt; ChannelOffset</p>"},{"location":"library/operators/channeloffset/#channeloffset","title":"ChannelOffset","text":"<pre><code>ChannelOffset(offset=0, input=None)\n</code></pre> <p>Offsets the input by a specified number of channels. With an N-channel input and an offset of M, the output will have M+N channels.</p>"},{"location":"library/operators/channelselect/","title":"ChannelSelect node documentation","text":"<p>Reference library &gt; Operators &gt; ChannelSelect</p>"},{"location":"library/operators/channelselect/#channelselect","title":"ChannelSelect","text":"<pre><code>ChannelSelect(input=None, offset=0, maximum=0, step=1)\n</code></pre> <p>Select a subset of channels from a multichannel input, starting at offset, up to a maximum of maximum, with the given step.</p>"},{"location":"library/operators/cos/","title":"Cos node documentation","text":"<p>Reference library &gt; Operators &gt; Cos</p>"},{"location":"library/operators/cos/#cos","title":"Cos","text":"<pre><code>Cos(a=0)\n</code></pre> <p>Outputs cos(a), per sample.</p>"},{"location":"library/operators/decibelstoamplitude/","title":"DecibelsToAmplitude node documentation","text":"<p>Reference library &gt; Operators &gt; DecibelsToAmplitude</p>"},{"location":"library/operators/decibelstoamplitude/#decibelstoamplitude","title":"DecibelsToAmplitude","text":"<pre><code>DecibelsToAmplitude(a=0)\n</code></pre> <p>DecibelsToAmplitude</p>"},{"location":"library/operators/divide/","title":"Divide node documentation","text":"<p>Reference library &gt; Operators &gt; Divide</p>"},{"location":"library/operators/divide/#divide","title":"Divide","text":"<pre><code>Divide(a=1, b=1)\n</code></pre> <p>Divide each sample of a by each sample of b. Can also be written as a / b</p>"},{"location":"library/operators/equal/","title":"Equal node documentation","text":"<p>Reference library &gt; Operators &gt; Equal</p>"},{"location":"library/operators/equal/#equal","title":"Equal","text":"<pre><code>Equal(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 1 when equal, 0 otherwise. Can also be written as a == b</p>"},{"location":"library/operators/frequencytomidinote/","title":"FrequencyToMidiNote node documentation","text":"<p>Reference library &gt; Operators &gt; FrequencyToMidiNote</p>"},{"location":"library/operators/frequencytomidinote/#frequencytomidinote","title":"FrequencyToMidiNote","text":"<pre><code>FrequencyToMidiNote(a=0)\n</code></pre> <p>Map a frequency to a MIDI note (where 440Hz = A4 = 69), with floating-point output.</p>"},{"location":"library/operators/greaterthan/","title":"GreaterThan node documentation","text":"<p>Reference library &gt; Operators &gt; GreaterThan</p>"},{"location":"library/operators/greaterthan/#greaterthan","title":"GreaterThan","text":"<pre><code>GreaterThan(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 1 when a &gt; b, 0 otherwise. Can also be written as a &gt; b</p>"},{"location":"library/operators/greaterthanorequal/","title":"GreaterThanOrEqual node documentation","text":"<p>Reference library &gt; Operators &gt; GreaterThanOrEqual</p>"},{"location":"library/operators/greaterthanorequal/#greaterthanorequal","title":"GreaterThanOrEqual","text":"<pre><code>GreaterThanOrEqual(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 1 when a &gt;= b, 0 otherwise. Can also be written as a &gt;= b</p>"},{"location":"library/operators/if/","title":"If node documentation","text":"<p>Reference library &gt; Operators &gt; If</p>"},{"location":"library/operators/if/#if","title":"If","text":"<pre><code>If(a=0, value_if_true=0, value_if_false=0)\n</code></pre> <p>Outputs value_if_true for each non-zero value of a, value_if_false for all other values.</p>"},{"location":"library/operators/lessthan/","title":"LessThan node documentation","text":"<p>Reference library &gt; Operators &gt; LessThan</p>"},{"location":"library/operators/lessthan/#lessthan","title":"LessThan","text":"<pre><code>LessThan(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 1 when a &lt; b, 0 otherwise. Can also be written as a &lt; b</p>"},{"location":"library/operators/lessthanorequal/","title":"LessThanOrEqual node documentation","text":"<p>Reference library &gt; Operators &gt; LessThanOrEqual</p>"},{"location":"library/operators/lessthanorequal/#lessthanorequal","title":"LessThanOrEqual","text":"<pre><code>LessThanOrEqual(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 1 when a &lt;= b, 0 otherwise. Can also be written as a &lt;= b</p>"},{"location":"library/operators/midinotetofrequency/","title":"MidiNoteToFrequency node documentation","text":"<p>Reference library &gt; Operators &gt; MidiNoteToFrequency</p>"},{"location":"library/operators/midinotetofrequency/#midinotetofrequency","title":"MidiNoteToFrequency","text":"<pre><code>MidiNoteToFrequency(a=0)\n</code></pre> <p>Map a MIDI note to a frequency (where 440Hz = A4 = 69), supporting floating-point input.</p>"},{"location":"library/operators/modulo/","title":"Modulo node documentation","text":"<p>Reference library &gt; Operators &gt; Modulo</p>"},{"location":"library/operators/modulo/#modulo","title":"Modulo","text":"<pre><code>Modulo(a=0, b=0)\n</code></pre> <p>Outputs the value of a modulo b, per sample. Supports fractional values. Can also be written as a % b</p>"},{"location":"library/operators/multiply/","title":"Multiply node documentation","text":"<p>Reference library &gt; Operators &gt; Multiply</p>"},{"location":"library/operators/multiply/#multiply","title":"Multiply","text":"<pre><code>Multiply(a=1.0, b=1.0)\n</code></pre> <p>Multiply each sample of a by each sample of b. Can also be written as a * b</p>"},{"location":"library/operators/notequal/","title":"NotEqual node documentation","text":"<p>Reference library &gt; Operators &gt; NotEqual</p>"},{"location":"library/operators/notequal/#notequal","title":"NotEqual","text":"<pre><code>NotEqual(a=0, b=0)\n</code></pre> <p>Compares the output of a to the output of b. Outputs 0 when equal, 1 otherwise. Can also be written as a != b</p>"},{"location":"library/operators/pow/","title":"Pow node documentation","text":"<p>Reference library &gt; Operators &gt; Pow</p>"},{"location":"library/operators/pow/#pow","title":"Pow","text":"<pre><code>Pow(a=0, b=0)\n</code></pre> <p>Outputs a to the power of b, per sample. Can also be written as a ** b</p>"},{"location":"library/operators/round/","title":"Round node documentation","text":"<p>Reference library &gt; Operators &gt; Round</p>"},{"location":"library/operators/round/#round","title":"Round","text":"<pre><code>Round(a=0)\n</code></pre> <p>Round the input to the nearest integer value.</p>"},{"location":"library/operators/roundtoscale/","title":"RoundToScale node documentation","text":"<p>Reference library &gt; Operators &gt; RoundToScale</p>"},{"location":"library/operators/roundtoscale/#roundtoscale","title":"RoundToScale","text":"<pre><code>RoundToScale(a=0)\n</code></pre> <p>Given a frequency input, generates a frequency output that is rounded to the nearest MIDI note. (TODO: Not very well named)</p>"},{"location":"library/operators/scalelinexp/","title":"ScaleLinExp node documentation","text":"<p>Reference library &gt; Operators &gt; ScaleLinExp</p>"},{"location":"library/operators/scalelinexp/#scalelinexp","title":"ScaleLinExp","text":"<pre><code>ScaleLinExp(input=0, a=0, b=1, c=1, d=10)\n</code></pre> <p>Scales the input from a linear range (between a and b) to an exponential range (between c and d).</p>"},{"location":"library/operators/scalelinlin/","title":"ScaleLinLin node documentation","text":"<p>Reference library &gt; Operators &gt; ScaleLinLin</p>"},{"location":"library/operators/scalelinlin/#scalelinlin","title":"ScaleLinLin","text":"<pre><code>ScaleLinLin(input=0, a=0, b=1, c=1, d=10)\n</code></pre> <p>Scales the input from a linear range (between a and b) to a linear range (between c and d).</p>"},{"location":"library/operators/selectinput/","title":"SelectInput node documentation","text":"<p>Reference library &gt; Operators &gt; SelectInput</p>"},{"location":"library/operators/selectinput/#selectinput","title":"SelectInput","text":"<pre><code>SelectInput(index=0)\n</code></pre> <p>Pass through the output of one or more <code>inputs</code>, based on the integer input index specified in <code>index</code>. Unlike <code>ChannelSelect</code>, inputs may be multichannel, and <code>index</code> can be modulated in real time.</p>"},{"location":"library/operators/sin/","title":"Sin node documentation","text":"<p>Reference library &gt; Operators &gt; Sin</p>"},{"location":"library/operators/sin/#sin","title":"Sin","text":"<pre><code>Sin(a=0)\n</code></pre> <p>Outputs sin(a), per sample.</p>"},{"location":"library/operators/subtract/","title":"Subtract node documentation","text":"<p>Reference library &gt; Operators &gt; Subtract</p>"},{"location":"library/operators/subtract/#subtract","title":"Subtract","text":"<pre><code>Subtract(a=0, b=0)\n</code></pre> <p>Subtract each sample of b from each sample of a. Can also be written as a - b</p>"},{"location":"library/operators/sum/","title":"Sum node documentation","text":"<p>Reference library &gt; Operators &gt; Sum</p>"},{"location":"library/operators/sum/#sum","title":"Sum","text":"<pre><code>Sum()\n</code></pre> <p>Sums the output of all of the input nodes, by sample.</p>"},{"location":"library/operators/tan/","title":"Tan node documentation","text":"<p>Reference library &gt; Operators &gt; Tan</p>"},{"location":"library/operators/tan/#tan","title":"Tan","text":"<pre><code>Tan(a=0)\n</code></pre> <p>Outputs tan(a), per sample.</p>"},{"location":"library/operators/tanh/","title":"Tanh node documentation","text":"<p>Reference library &gt; Operators &gt; Tanh</p>"},{"location":"library/operators/tanh/#tanh","title":"Tanh","text":"<pre><code>Tanh(a=0)\n</code></pre> <p>Outputs tanh(a), per sample. Can be used as a soft clipper.</p>"},{"location":"library/operators/timeshift/","title":"TimeShift node documentation","text":"<p>Reference library &gt; Operators &gt; TimeShift</p>"},{"location":"library/operators/timeshift/#timeshift","title":"TimeShift","text":"<pre><code>TimeShift(a=0)\n</code></pre> <p>TimeShift</p>"},{"location":"library/operators/triggermult/","title":"TriggerMult node documentation","text":"<p>Reference library &gt; Operators &gt; TriggerMult</p>"},{"location":"library/operators/triggermult/#triggermult","title":"TriggerMult","text":"<pre><code>TriggerMult(a=0)\n</code></pre> <p>Distribute any triggers to all output nodes.</p>"},{"location":"library/oscillators/","title":"Oscillators","text":"<p>Reference library &gt; Oscillators</p>"},{"location":"library/oscillators/#oscillators","title":"Oscillators","text":"<ul> <li>Impulse: Produces a value of 1 at the given <code>frequency</code>, with output of 0 at all other times. If frequency is 0, produces a single impulse.</li> <li>SawLFO: Produces a sawtooth LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</li> <li>SawOscillator: Produces a (non-band-limited) sawtooth wave, with the given <code>frequency</code> and <code>phase</code> offset. When a <code>reset</code> or trigger is received, resets the phase to zero.</li> <li>SineLFO: Produces a sinusoidal LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</li> <li>SineOscillator: Produces a sine wave at the given <code>frequency</code>.</li> <li>SquareLFO: Produces a pulse wave LFO with the given <code>frequency</code> and pulse <code>width</code>,  ranging from <code>min</code> to <code>max</code>, where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</li> <li>SquareOscillator: Produces a pulse wave with the given <code>frequency</code> and pulse <code>width</code>,  where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</li> <li>TriangleLFO: Produces a triangle LFO with the given <code>frequency</code> and <code>phase</code> offset, ranging from <code>min</code> to <code>max</code>.</li> <li>TriangleOscillator: Produces a triangle wave with the given <code>frequency</code>.</li> <li>Wavetable: Plays the wavetable stored in buffer at the given <code>frequency</code> and <code>phase</code> offset. <code>sync</code> can be used to provide a hard sync input, which resets the wavetable's phase at each zero-crossing.</li> <li>Wavetable2D: Wavetable2D</li> </ul>"},{"location":"library/oscillators/constant/","title":"Constant node documentation","text":"<p>Reference library &gt; Oscillators &gt; Constant</p>"},{"location":"library/oscillators/constant/#constant","title":"Constant","text":"<pre><code>Constant(value=0)\n</code></pre> <p>Produces a constant value.</p>"},{"location":"library/oscillators/impulse/","title":"Impulse node documentation","text":"<p>Reference library &gt; Oscillators &gt; Impulse</p>"},{"location":"library/oscillators/impulse/#impulse","title":"Impulse","text":"<pre><code>Impulse(frequency=1.0)\n</code></pre> <p>Produces a value of 1 at the given <code>frequency</code>, with output of 0 at all other times. If frequency is 0, produces a single impulse.</p>"},{"location":"library/oscillators/impulse/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using an Impulse node as a clock to trigger an envelope once per second.\n#-------------------------------------------------------------------------------\nclock = Impulse(1.0)\nosc = TriangleOscillator(250)\nenvelope = ASREnvelope(0.01, 0.0, 0.5, 1.0, clock)\noutput = StereoPanner(osc * envelope)\noutput.play()\n</code></pre>"},{"location":"library/oscillators/sawlfo/","title":"SawLFO node documentation","text":"<p>Reference library &gt; Oscillators &gt; SawLFO</p>"},{"location":"library/oscillators/sawlfo/#sawlfo","title":"SawLFO","text":"<pre><code>SawLFO(frequency=1.0, min=0.0, max=1.0, phase=0.0)\n</code></pre> <p>Produces a sawtooth LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</p>"},{"location":"library/oscillators/sawlfo/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Siren effect, using a sawtooth LFO to modulate a sinewave's frequency\n#-------------------------------------------------------------------------------\nlfo = SawLFO(1, 200, 1000)\nsine = SineOscillator(lfo)\noutput = StereoPanner(sine) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/sawoscillator/","title":"SawOscillator node documentation","text":"<p>Reference library &gt; Oscillators &gt; SawOscillator</p>"},{"location":"library/oscillators/sawoscillator/#sawoscillator","title":"SawOscillator","text":"<pre><code>SawOscillator(frequency=440, phase_offset=None, reset=None)\n</code></pre> <p>Produces a (non-band-limited) sawtooth wave, with the given <code>frequency</code> and <code>phase</code> offset. When a <code>reset</code> or trigger is received, resets the phase to zero.</p>"},{"location":"library/oscillators/sawoscillator/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Simple saw wave oscillator shaped by an envelope\n#-------------------------------------------------------------------------------\nsaw = SawOscillator(440)\nenvelope = ASREnvelope(0.05, 0.1, 0.5)\noutput = StereoPanner(saw * envelope) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/sinelfo/","title":"SineLFO node documentation","text":"<p>Reference library &gt; Oscillators &gt; SineLFO</p>"},{"location":"library/oscillators/sinelfo/#sinelfo","title":"SineLFO","text":"<pre><code>SineLFO(frequency=1.0, min=0.0, max=1.0, phase=0.0)\n</code></pre> <p>Produces a sinusoidal LFO at the given <code>frequency</code> and <code>phase</code> offset, with output ranging from <code>min</code> to <code>max</code>.</p>"},{"location":"library/oscillators/sinelfo/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Siren effect, using a sinewave LFO to modulate a sawtooth's frequency\n#-------------------------------------------------------------------------------\nlfo = SineLFO(1, 200, 1000)\nsaw = SawOscillator(lfo)\noutput = StereoPanner(saw) * 0.3\noutput.play()\n</code></pre>"},{"location":"library/oscillators/sineoscillator/","title":"SineOscillator node documentation","text":"<p>Reference library &gt; Oscillators &gt; SineOscillator</p>"},{"location":"library/oscillators/sineoscillator/#sineoscillator","title":"SineOscillator","text":"<pre><code>SineOscillator(frequency=440, phase_offset=None, reset=None)\n</code></pre> <p>Produces a sine wave at the given <code>frequency</code>.</p>"},{"location":"library/oscillators/sineoscillator/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Simple sine wave oscillator shaped by an envelope\n#-------------------------------------------------------------------------------\nsine = SineOscillator(440)\nenvelope = ASREnvelope(0.1, 0.1, 0.5)\noutput = StereoPanner(sine * envelope) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/squarelfo/","title":"SquareLFO node documentation","text":"<p>Reference library &gt; Oscillators &gt; SquareLFO</p>"},{"location":"library/oscillators/squarelfo/#squarelfo","title":"SquareLFO","text":"<pre><code>SquareLFO(frequency=1.0, min=0.0, max=1.0, width=0.5, phase=0.0)\n</code></pre> <p>Produces a pulse wave LFO with the given <code>frequency</code> and pulse <code>width</code>,  ranging from <code>min</code> to <code>max</code>, where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</p>"},{"location":"library/oscillators/squarelfo/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Alarm effect, using a pulse wave LFO to modulate a sinewave's frequency\n#-------------------------------------------------------------------------------\nlfo = SquareLFO(1, 200, 400)\nsine = SineOscillator(lfo)\noutput = StereoPanner(sine) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/squareoscillator/","title":"SquareOscillator node documentation","text":"<p>Reference library &gt; Oscillators &gt; SquareOscillator</p>"},{"location":"library/oscillators/squareoscillator/#squareoscillator","title":"SquareOscillator","text":"<pre><code>SquareOscillator(frequency=440, width=0.5)\n</code></pre> <p>Produces a pulse wave with the given <code>frequency</code> and pulse <code>width</code>,  where <code>width</code> of <code>0.5</code> is a square wave and other values produce a rectangular wave.</p>"},{"location":"library/oscillators/squareoscillator/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Simple square wave oscillator shaped by an envelope\n#-------------------------------------------------------------------------------\nsquare = SquareOscillator(440)\nenvelope = ASREnvelope(0, 0.1, 0.5)\noutput = StereoPanner(square * envelope) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/trianglelfo/","title":"TriangleLFO node documentation","text":"<p>Reference library &gt; Oscillators &gt; TriangleLFO</p>"},{"location":"library/oscillators/trianglelfo/#trianglelfo","title":"TriangleLFO","text":"<pre><code>TriangleLFO(frequency=1.0, min=0.0, max=1.0, phase=0.0)\n</code></pre> <p>Produces a triangle LFO with the given <code>frequency</code> and <code>phase</code> offset, ranging from <code>min</code> to <code>max</code>.</p>"},{"location":"library/oscillators/trianglelfo/#examples","title":"Examples","text":"<pre><code>#-----------------------------------------------------------------------------------\n# Pacman ghost sound, using a triangle wave LFO to modulate a sine wave's frequency\n#-----------------------------------------------------------------------------------\nlfo = TriangleLFO(3, 200, 900)\nsine = SineOscillator(lfo)\noutput = StereoPanner(sine) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/triangleoscillator/","title":"TriangleOscillator node documentation","text":"<p>Reference library &gt; Oscillators &gt; TriangleOscillator</p>"},{"location":"library/oscillators/triangleoscillator/#triangleoscillator","title":"TriangleOscillator","text":"<pre><code>TriangleOscillator(frequency=440)\n</code></pre> <p>Produces a triangle wave with the given <code>frequency</code>.</p>"},{"location":"library/oscillators/triangleoscillator/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Simple triangle wave oscillator shaped by an envelope\n#-------------------------------------------------------------------------------\ntri = TriangleOscillator(440)\nenvelope = ASREnvelope(0.1, 0.1, 0.5)\noutput = StereoPanner(tri * envelope) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/oscillators/wavetable/","title":"Wavetable node documentation","text":"<p>Reference library &gt; Oscillators &gt; Wavetable</p>"},{"location":"library/oscillators/wavetable/#wavetable","title":"Wavetable","text":"<pre><code>Wavetable(buffer=None, frequency=440, phase_offset=0, sync=0, phase_map=None)\n</code></pre> <p>Plays the wavetable stored in buffer at the given <code>frequency</code> and <code>phase</code> offset. <code>sync</code> can be used to provide a hard sync input, which resets the wavetable's phase at each zero-crossing.</p>"},{"location":"library/oscillators/wavetable2d/","title":"Wavetable2D node documentation","text":"<p>Reference library &gt; Oscillators &gt; Wavetable2D</p>"},{"location":"library/oscillators/wavetable2d/#wavetable2d","title":"Wavetable2D","text":"<pre><code>Wavetable2D(buffer=None, frequency=440, crossfade=0.0, phase_offset=0.0, sync=0)\n</code></pre> <p>Wavetable2D</p>"},{"location":"library/physical/","title":"Index","text":"<p>Reference library &gt; Physical</p>"},{"location":"library/physical/#physical","title":"Physical","text":"<ul> <li>Maraca: Physically-inspired model of a maraca.</li> </ul>"},{"location":"library/physical/maraca/","title":"Maraca node documentation","text":"<p>Reference library &gt; Physical &gt; Maraca</p>"},{"location":"library/physical/maraca/#maraca","title":"Maraca","text":"<pre><code>Maraca(num_beans=64, shake_decay=0.99, grain_decay=0.99, shake_duration=0.02, shell_frequency=12000, shell_resonance=0.9, clock=None, energy=None)\n</code></pre> <p>Physically-inspired model of a maraca. </p> <p>Parameters: - <code>num_beans</code>: The number of simulated beans in the maraca (1-1024) - <code>shake_decay</code>: Decay constant for the energy injected per shake - <code>grain_decay</code>: Decay constant for the energy created per bean collision - <code>shake_duration</code>: Duration of each shake action, milliseconds - <code>shell_frequency</code>: Resonant frequency of the maraca's shell, hertz - <code>shell_resonance</code>: Resonanc of the maraca's shell (0-1) - <code>clock</code>: If specified, triggers shake actions - <code>energy</code>: If specified, injects energy into the maraca </p> <p>From Cook (1997), \\\"Physically Informed Sonic Modeling (PhISM): Synthesis of Percussive Sounds\\\", Computer Music Journal.</p>"},{"location":"library/processors/","title":"Processors","text":"<p>Reference library &gt; Processors</p>"},{"location":"library/processors/#processors","title":"Processors","text":"<ul> <li>Clip: Clip the input to <code>min</code>/<code>max</code>.</li> <li>Fold: Fold the input beyond <code>min</code>/<code>max</code>, reflecting the excess back.</li> <li>Smooth: Smooth the input with a given smoothing coefficient. When <code>smooth</code> = 0, applies no smoothing.</li> <li>WetDry: Takes <code>wet</code> and <code>dry</code> inputs, and outputs a mix determined by <code>wetness</code>.</li> <li>Wrap: Wrap the input beyond <code>min</code>/<code>max</code>.</li> </ul>"},{"location":"library/processors/clip/","title":"Clip node documentation","text":"<p>Reference library &gt; Processors &gt; Clip</p>"},{"location":"library/processors/clip/#clip","title":"Clip","text":"<pre><code>Clip(input=None, min=-1.0, max=1.0)\n</code></pre> <p>Clip the input to <code>min</code>/<code>max</code>.</p>"},{"location":"library/processors/delays/","title":"Processors: Delays","text":"<p>Reference library &gt; Processors: Delays</p>"},{"location":"library/processors/delays/#processors-delays","title":"Processors: Delays","text":"<ul> <li>AllpassDelay: All-pass delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>CombDelay: Comb delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>OneTapDelay: Single-tap delay line. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</li> <li>Stutter: Stutters the input whenever a trigger is received on <code>clock</code>. Generates <code>stutter_count</code> repeats, with duration of <code>stutter_time</code>.</li> </ul>"},{"location":"library/processors/delays/allpassdelay/","title":"AllpassDelay node documentation","text":"<p>Reference library &gt; Processors: Delays &gt; AllpassDelay</p>"},{"location":"library/processors/delays/allpassdelay/#allpassdelay","title":"AllpassDelay","text":"<pre><code>AllpassDelay(input=0.0, delay_time=0.1, feedback=0.5, max_delay_time=0.5)\n</code></pre> <p>All-pass delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</p>"},{"location":"library/processors/delays/allpassdelay/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using AllpassDelay to add a delay effect to a simple melodic sequence.\n# The original oscillator can be heard in the left channel.\n# The delay effect can be heard in the right channel.\n#-------------------------------------------------------------------------------\nclock = Impulse(1.0)\nsequence = Sequence([ 60, 62, 64, 65, 67, 69, 71, 72 ], clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = TriangleOscillator(frequency)\nenvelope = ASREnvelope(0, 0.2, 0.3, 1.0, clock)\nvoice = oscillator * envelope\ndelayed = AllpassDelay(input=voice, \n                       delay_time=0.4, \n                       feedback=0.8)\n\noutput = ChannelArray([ voice, delayed ]) * 0.75\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using AllpassDelay to add a dreamy atmosphere to synth arpeggios\n#-------------------------------------------------------------------------------\nclock = Impulse(3.5)\nAm7 = [ 67, 64, 60, 57 ] * 4\nD7 = [ 62, 66, 69, 72] * 4\narpeggios = Am7 + D7\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = SquareOscillator(frequency)\nenvelope = ASREnvelope(0.1, 0, 0.2, 1.0, clock)\nvoice = oscillator * envelope\nfiltered = SVFilter(voice, \"low_pass\", 4000, 0.3)\ndelayed = AllpassDelay(input=filtered, \n                       delay_time=0.15, \n                       feedback=0.8)\n\npan = TriangleLFO(0.1, -1.0, 1.0)\noutput = StereoPanner(delayed, pan) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/processors/delays/combdelay/","title":"CombDelay node documentation","text":"<p>Reference library &gt; Processors: Delays &gt; CombDelay</p>"},{"location":"library/processors/delays/combdelay/#combdelay","title":"CombDelay","text":"<pre><code>CombDelay(input=0.0, delay_time=0.1, feedback=0.5, max_delay_time=0.5)\n</code></pre> <p>Comb delay, with <code>feedback</code> between 0 and 1. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</p>"},{"location":"library/processors/delays/combdelay/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using CombDelay to change the character of a saw wave oscillator.\n#-------------------------------------------------------------------------------\nclock = Impulse(4)\narpeggio = [60, 62, 64, 66, 68, 70,\n            72, 70, 68, 66, 64, 62]\nsequence = Sequence(arpeggio, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = SawOscillator(frequency)\nenvelope = ASREnvelope(0.1, 0, 0.2, 1.0, clock)\nvoice = oscillator * envelope\ncomb = CombDelay(input=voice, \n                 delay_time=0.09, \n                 feedback=0.6, \n                 max_delay_time=0.9)\n\noutput = StereoPanner(comb) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/processors/delays/onetapdelay/","title":"OneTapDelay node documentation","text":"<p>Reference library &gt; Processors: Delays &gt; OneTapDelay</p>"},{"location":"library/processors/delays/onetapdelay/#onetapdelay","title":"OneTapDelay","text":"<pre><code>OneTapDelay(input=0.0, delay_time=0.1, max_delay_time=0.5)\n</code></pre> <p>Single-tap delay line. <code>delay_time</code> must be less than or equal to <code>max_delay_time</code>.</p>"},{"location":"library/processors/delays/onetapdelay/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using OneTapDelay to create a delay effect with no feedback.\n# The original sound is heard in the left channel, and the delayed sound in the\n# right channel.\n#-------------------------------------------------------------------------------\nclock = Impulse(1)\noscillator = TriangleOscillator(440)\nenvelope = ASREnvelope(0.001, 0, 0.3, 1.0, clock)\nvoice = oscillator * envelope\ndelayed = OneTapDelay(voice, 0.25) * 0.5\noutput = ChannelArray([voice, delayed]) * 0.5\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using OneTapDelay to bring controlled rhythmic interest to a melodic sequence\n#-------------------------------------------------------------------------------\nclock = Impulse(3.5)\nDm = [ 62, 65, 69 ] * 2\nBdim = [ 59, 62, 65 ] * 2\nGm = [55, 58, 62 ] * 2\nBb = [77, 74, 70 ]\nA = [ 76, 73, 69 ]\n\narpeggios = Dm + Bdim + Gm + Bb + A\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = SquareOscillator(frequency)\nenvelope = ASREnvelope(0.1, 0, 0.2, 1.0, clock)\nvoice = oscillator * envelope\nfiltered = SVFilter(voice, \"low_pass\", 4000, 0.3)\ndelayed = filtered + OneTapDelay(filtered, 0.4) * 0.5\n\noutput = StereoPanner(delayed) * 0.3\noutput.play()\n</code></pre>"},{"location":"library/processors/delays/stutter/","title":"Stutter node documentation","text":"<p>Reference library &gt; Processors: Delays &gt; Stutter</p>"},{"location":"library/processors/delays/stutter/#stutter","title":"Stutter","text":"<pre><code>Stutter(input=0.0, stutter_time=0.1, stutter_count=1, stutter_probability=1.0, stutter_advance_time=0.0, clock=None, max_stutter_time=1.0)\n</code></pre> <p>Stutters the input whenever a trigger is received on <code>clock</code>. Generates <code>stutter_count</code> repeats, with duration of <code>stutter_time</code>.</p>"},{"location":"library/processors/distortion/","title":"Processors: Distortion","text":"<p>Reference library &gt; Processors: Distortion</p>"},{"location":"library/processors/distortion/#processors-distortion","title":"Processors: Distortion","text":"<ul> <li>Resample: Resampler and bit crusher. <code>sample_rate</code> is in Hz, <code>bit_rate</code> is an integer between 0 and 16.</li> <li>SampleAndHold: Samples and holds the input each time a trigger is received on <code>clock</code>.</li> <li>Squiz: Implementation of Dan Stowell's Squiz algorithm, a kind of downsampler.</li> <li>WaveShaper: Applies wave-shaping as described in the WaveShaperBuffer <code>buffer</code>.</li> </ul>"},{"location":"library/processors/distortion/resample/","title":"Resample node documentation","text":"<p>Reference library &gt; Processors: Distortion &gt; Resample</p>"},{"location":"library/processors/distortion/resample/#resample","title":"Resample","text":"<pre><code>Resample(input=0, sample_rate=44100, bit_rate=16)\n</code></pre> <p>Resampler and bit crusher. <code>sample_rate</code> is in Hz, <code>bit_rate</code> is an integer between 0 and 16.</p>"},{"location":"library/processors/distortion/resample/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using Resample to distort a sine wave.\n#-------------------------------------------------------------------------------\nsine = SineOscillator(440)\ncrushed = Resample(sine, 11025, 4)\noutput = StereoPanner(crushed) * 0.3\noutput.play()\n</code></pre>"},{"location":"library/processors/distortion/sampleandhold/","title":"SampleAndHold node documentation","text":"<p>Reference library &gt; Processors: Distortion &gt; SampleAndHold</p>"},{"location":"library/processors/distortion/sampleandhold/#sampleandhold","title":"SampleAndHold","text":"<pre><code>SampleAndHold(input=None, clock=None)\n</code></pre> <p>Samples and holds the input each time a trigger is received on <code>clock</code>.</p>"},{"location":"library/processors/distortion/squiz/","title":"Squiz node documentation","text":"<p>Reference library &gt; Processors: Distortion &gt; Squiz</p>"},{"location":"library/processors/distortion/squiz/#squiz","title":"Squiz","text":"<pre><code>Squiz(input=0.0, rate=2.0, chunk_size=1)\n</code></pre> <p>Implementation of Dan Stowell's Squiz algorithm, a kind of downsampler.</p>"},{"location":"library/processors/distortion/waveshaper/","title":"WaveShaper node documentation","text":"<p>Reference library &gt; Processors: Distortion &gt; WaveShaper</p>"},{"location":"library/processors/distortion/waveshaper/#waveshaper","title":"WaveShaper","text":"<pre><code>WaveShaper(input=0.0, buffer=None)\n</code></pre> <p>Applies wave-shaping as described in the WaveShaperBuffer <code>buffer</code>.</p>"},{"location":"library/processors/distortion/waveshaper/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Create a waveshaper buffer that silences any samples with amplitude &lt; 0.5\n#-------------------------------------------------------------------------------\nbuf = WaveShaperBuffer(lambda n: 0 if abs(n) &lt; 0.5 else n)\nsine = SineOscillator(120)\nwaveshaper = WaveShaper(sine, buf)\nattenuated = waveshaper * 0.1\nattenuated.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Create a range of different waveshaper buffers, and iterate through them.\n#-------------------------------------------------------------------------------\nimport time\nimport math\nimport random\n\nsin_buf = WaveShaperBuffer(lambda n: math.sin(n * math.pi / 2))\ncos_buf = WaveShaperBuffer(lambda n: math.cos(n * math.pi / 2))\ntan_buf = WaveShaperBuffer(lambda n: math.tan(n * math.pi / 2))\ntanh_buf = WaveShaperBuffer(lambda n: math.tanh(n * 20))\nsinx_buf = WaveShaperBuffer(lambda n: math.sin(256 * n * math.pi / 2))\ninvert_buf = WaveShaperBuffer(lambda n: 1 - n if n &gt; 0 else -1 - n)\nnoise_buf = WaveShaperBuffer(lambda n: random.uniform(0, n))\nbufs = [sin_buf, cos_buf, tan_buf, tanh_buf, sinx_buf, invert_buf, noise_buf]\n\nsine = SineOscillator(120)\nwaveshaper = WaveShaper(sine, sin_buf)\nattenuated = waveshaper * 0.1\nattenuated.play()\n\nfor buf in bufs:\n    waveshaper.set_buffer(\"buffer\", buf)\n    time.sleep(1.0)\n\nattenuated.stop()\n</code></pre>"},{"location":"library/processors/dynamics/","title":"Processors: Dynamics","text":"<p>Reference library &gt; Processors: Dynamics</p>"},{"location":"library/processors/dynamics/#processors-dynamics","title":"Processors: Dynamics","text":"<ul> <li>Compressor: Dynamic range compression, with optional <code>sidechain</code> input. When the input amplitude is above <code>threshold</code>, compresses the amplitude with the given <code>ratio</code>, following the given <code>attack_time</code> and <code>release_time</code> in seconds.</li> <li>Gate: Outputs the input value when it is above the given <code>threshold</code>, otherwise zero.</li> <li>Maximiser: Gain maximiser.</li> <li>RMS: Outputs the root-mean-squared value of the input, in buffers equal to the graph's current buffer size.</li> </ul>"},{"location":"library/processors/dynamics/compressor/","title":"Compressor node documentation","text":"<p>Reference library &gt; Processors: Dynamics &gt; Compressor</p>"},{"location":"library/processors/dynamics/compressor/#compressor","title":"Compressor","text":"<pre><code>Compressor(input=0.0, threshold=0.1, ratio=2, attack_time=0.01, release_time=0.1, sidechain=None)\n</code></pre> <p>Dynamic range compression, with optional <code>sidechain</code> input. When the input amplitude is above <code>threshold</code>, compresses the amplitude with the given <code>ratio</code>, following the given <code>attack_time</code> and <code>release_time</code> in seconds.</p>"},{"location":"library/processors/dynamics/gate/","title":"Gate node documentation","text":"<p>Reference library &gt; Processors: Dynamics &gt; Gate</p>"},{"location":"library/processors/dynamics/gate/#gate","title":"Gate","text":"<pre><code>Gate(input=0.0, threshold=0.1)\n</code></pre> <p>Outputs the input value when it is above the given <code>threshold</code>, otherwise zero.</p>"},{"location":"library/processors/dynamics/maximiser/","title":"Maximiser node documentation","text":"<p>Reference library &gt; Processors: Dynamics &gt; Maximiser</p>"},{"location":"library/processors/dynamics/maximiser/#maximiser","title":"Maximiser","text":"<pre><code>Maximiser(input=0.0, ceiling=0.5, attack_time=1.0, release_time=1.0)\n</code></pre> <p>Gain maximiser.</p>"},{"location":"library/processors/dynamics/rms/","title":"RMS node documentation","text":"<p>Reference library &gt; Processors: Dynamics &gt; RMS</p>"},{"location":"library/processors/dynamics/rms/#rms","title":"RMS","text":"<pre><code>RMS(input=0.0)\n</code></pre> <p>Outputs the root-mean-squared value of the input, in buffers equal to the graph's current buffer size.</p>"},{"location":"library/processors/filters/","title":"Processors: Filters","text":"<p>Reference library &gt; Processors: Filters</p>"},{"location":"library/processors/filters/#processors-filters","title":"Processors: Filters","text":"<ul> <li>BiquadFilter: Biquad filter. filter_type can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. Not recommended for real-time modulation; for this, use SVFilter.</li> <li>DCFilter: Remove low-frequency and DC content from a signal.</li> <li>EQ: Three-band EQ.</li> <li>MoogVCF: Simulation of the Moog ladder low-pass filter. <code>cutoff</code> sets the cutoff frequency; <code>resonance</code> should typically be between 0..1.</li> <li>SVFilter: State variable filter. <code>filter_type</code> can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. <code>resonance</code> should be between <code>[0..1]</code>.</li> </ul>"},{"location":"library/processors/filters/biquadfilter/","title":"BiquadFilter node documentation","text":"<p>Reference library &gt; Processors: Filters &gt; BiquadFilter</p>"},{"location":"library/processors/filters/biquadfilter/#biquadfilter","title":"BiquadFilter","text":"<pre><code>BiquadFilter(input=0.0, filter_type=SIGNALFLOW_FILTER_TYPE_LOW_PASS, cutoff=440, resonance=0.0, peak_gain=0.0)\n</code></pre> <p>Biquad filter. filter_type can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. Not recommended for real-time modulation; for this, use SVFilter.</p>"},{"location":"library/processors/filters/dcfilter/","title":"DCFilter node documentation","text":"<p>Reference library &gt; Processors: Filters &gt; DCFilter</p>"},{"location":"library/processors/filters/dcfilter/#dcfilter","title":"DCFilter","text":"<pre><code>DCFilter(input=0.0)\n</code></pre> <p>Remove low-frequency and DC content from a signal.</p>"},{"location":"library/processors/filters/eq/","title":"EQ node documentation","text":"<p>Reference library &gt; Processors: Filters &gt; EQ</p>"},{"location":"library/processors/filters/eq/#eq","title":"EQ","text":"<pre><code>EQ(input=0.0, low_gain=1.0, mid_gain=1.0, high_gain=1.0, low_freq=500, high_freq=5000)\n</code></pre> <p>Three-band EQ.</p>"},{"location":"library/processors/filters/eq/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using EQ to shape white noise. The low band (below 500Hz) is reduced. The mid\n# band is boosted. The high band (above 2000Hz) is reduced drastically.\n#-------------------------------------------------------------------------------\nnoise = WhiteNoise()\neq = EQ(input=noise, \n        low_gain=0.0, \n        mid_gain=1.5, \n        high_gain=0.2, \n        low_freq=1000, \n        high_freq=2000)\noutput = StereoPanner(eq) * 0.5\noutput.play()\n</code></pre>"},{"location":"library/processors/filters/moogvcf/","title":"MoogVCF node documentation","text":"<p>Reference library &gt; Processors: Filters &gt; MoogVCF</p>"},{"location":"library/processors/filters/moogvcf/#moogvcf","title":"MoogVCF","text":"<pre><code>MoogVCF(input=0.0, cutoff=200.0, resonance=0.0)\n</code></pre> <p>Simulation of the Moog ladder low-pass filter. <code>cutoff</code> sets the cutoff frequency; <code>resonance</code> should typically be between 0..1.</p>"},{"location":"library/processors/filters/svfilter/","title":"SVFilter node documentation","text":"<p>Reference library &gt; Processors: Filters &gt; SVFilter</p>"},{"location":"library/processors/filters/svfilter/#svfilter","title":"SVFilter","text":"<pre><code>SVFilter(input=0.0, filter_type=SIGNALFLOW_FILTER_TYPE_LOW_PASS, cutoff=440, resonance=0.0)\n</code></pre> <p>State variable filter. <code>filter_type</code> can be 'low_pass', 'band_pass', 'high_pass', 'notch', 'peak', 'low_shelf', 'high_shelf'. <code>resonance</code> should be between <code>[0..1]</code>.</p>"},{"location":"library/processors/filters/svfilter/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using SVFilter as a low-pass filter on white noise.\n#-------------------------------------------------------------------------------\nnoise = WhiteNoise()\nfiltered = SVFilter(input=noise,\n                    filter_type=\"low_pass\", \n                    cutoff=1000, \n                    resonance=0.6)\noutput = StereoPanner(filtered)\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using SVFilter as a low-pass filter to reduce the harshness of a square wave\n# oscillator.\n#-------------------------------------------------------------------------------\nclock = Impulse(3.5)\nAm7 = [ 67, 64, 60, 57 ] * 4\nD7 = [ 62, 66, 69, 72] * 4\narpeggios = Am7 + D7\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = SquareOscillator(frequency)\nenvelope = ASREnvelope(0.1, 0, 0.2, 1.0, clock)\nvoice = oscillator * envelope \nfiltered = SVFilter(input=voice,\n                    filter_type= \"low_pass\", \n                    cutoff=4000, \n                    resonance=0.3)\ndelayed = AllpassDelay(filtered, 0.15, 0.8, 0.5)\n\npan = TriangleLFO(0.1, -1.0, 1.0)\noutput = StereoPanner(delayed, pan) * 0.3\noutput.play()\n</code></pre>"},{"location":"library/processors/fold/","title":"Fold node documentation","text":"<p>Reference library &gt; Processors &gt; Fold</p>"},{"location":"library/processors/fold/#fold","title":"Fold","text":"<pre><code>Fold(input=None, min=-1.0, max=1.0)\n</code></pre> <p>Fold the input beyond <code>min</code>/<code>max</code>, reflecting the excess back.</p>"},{"location":"library/processors/panning/","title":"Processors: Panning","text":"<p>Reference library &gt; Processors: Panning</p>"},{"location":"library/processors/panning/#processors-panning","title":"Processors: Panning","text":"<ul> <li>AzimuthPanner: Pan input around an equally-spaced ring of <code>num_channels</code> speakers. <code>pan</code> is the pan position from -1..+1, where 0 = centre front. <code>width</code> is the source's width, where 1.0 spans exactly between an adjacent pair of channels.</li> <li>ChannelPanner: Pan the input between a linear series of channels, where <code>pan</code> 0 = channel 0, 1 = channel 1, etc. No wrapping is applied.</li> <li>SpatialPanner: Implements a spatial panning algorithm, applied to a given SpatialEnvironment. Currently, only DBAP is supported.</li> <li>StereoBalance: Takes a stereo input and rebalances it, where <code>balance</code> of <code>0</code> is unchanged, <code>-1</code> is hard left, and <code>1</code> is hard right.</li> <li>StereoPanner: Pans a mono input to a stereo output. <code>pan</code> should be between -1 (hard left) to +1 (hard right), with 0 = centre.</li> <li>StereoWidth: Reduces the width of a stereo signal. When <code>width</code> = 1, input is unchanged. When <code>width</code> = 0, outputs a pair of identical channels both containing L+R.</li> </ul>"},{"location":"library/processors/panning/azimuthpanner/","title":"AzimuthPanner node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; AzimuthPanner</p>"},{"location":"library/processors/panning/azimuthpanner/#azimuthpanner","title":"AzimuthPanner","text":"<pre><code>AzimuthPanner(num_channels=2, input=0, pan=0.0, width=1.0)\n</code></pre> <p>Pan input around an equally-spaced ring of <code>num_channels</code> speakers. <code>pan</code> is the pan position from -1..+1, where 0 = centre front. <code>width</code> is the source's width, where 1.0 spans exactly between an adjacent pair of channels.</p>"},{"location":"library/processors/panning/channelpanner/","title":"ChannelPanner node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; ChannelPanner</p>"},{"location":"library/processors/panning/channelpanner/#channelpanner","title":"ChannelPanner","text":"<pre><code>ChannelPanner(num_channels=2, input=0, pan=0.0, width=1.0)\n</code></pre> <p>Pan the input between a linear series of channels, where <code>pan</code> 0 = channel 0, 1 = channel 1, etc. No wrapping is applied.</p>"},{"location":"library/processors/panning/spatialpanner/","title":"SpatialPanner node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; SpatialPanner</p>"},{"location":"library/processors/panning/spatialpanner/#spatialpanner","title":"SpatialPanner","text":"<pre><code>SpatialPanner(env=None, input=0.0, x=0.0, y=0.0, z=0.0, radius=1.0, use_delays=1.0, algorithm=\"dbap\")\n</code></pre> <p>Implements a spatial panning algorithm, applied to a given SpatialEnvironment. Currently, only DBAP is supported.</p>"},{"location":"library/processors/panning/stereobalance/","title":"StereoBalance node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; StereoBalance</p>"},{"location":"library/processors/panning/stereobalance/#stereobalance","title":"StereoBalance","text":"<pre><code>StereoBalance(input=0, balance=0)\n</code></pre> <p>Takes a stereo input and rebalances it, where <code>balance</code> of <code>0</code> is unchanged, <code>-1</code> is hard left, and <code>1</code> is hard right.</p>"},{"location":"library/processors/panning/stereobalance/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Demonstrating the effects of StereoBalance. First a low tone is assigned to \n# the left channel and a high tone is assigned to the right channel.\n# Setting StereoBalance's balance value to 0.0 will mean both tones are heard \n# equally. A value of -1.0 will result in only the left channel being heard. \n# A value of 1.0 will result in only the right channel being heard.\n# In this example, an LFO is modulating the balance value between -1.0 and 1.0.\n#-------------------------------------------------------------------------------\nlow = TriangleOscillator(220)\nhigh = TriangleOscillator(660)\npanned = ChannelArray([low, high])\nbalanced = StereoBalance(panned, TriangleLFO(0.2, -1, 1)) * 0.5\nbalanced.play()\n</code></pre>"},{"location":"library/processors/panning/stereopanner/","title":"StereoPanner node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; StereoPanner</p>"},{"location":"library/processors/panning/stereopanner/#stereopanner","title":"StereoPanner","text":"<pre><code>StereoPanner(input=0, pan=0.0)\n</code></pre> <p>Pans a mono input to a stereo output. <code>pan</code> should be between -1 (hard left) to +1 (hard right), with 0 = centre.</p>"},{"location":"library/processors/panning/stereopanner/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using StereoPanner to pan a low pitch to the left and a high pitch to the\n# right.\n#-------------------------------------------------------------------------------\nlow = TriangleOscillator(220)\nhigh = TriangleOscillator(660)\n\nleft = StereoPanner(low, -0.8)\nright = StereoPanner(high, 0.8)\n\noutput = (left + right) * 0.5\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using StereoPanner to repeatedly pan an arpeggiating oscillator between the \n# left and right channels.\n#-------------------------------------------------------------------------------\nclock = Impulse(8.0)\nCMaj7 = [ 60, 64, 67, 71, 74, 76 ] * 8\nFMaj9 = [ 65, 69, 72, 76, 77, 81 ] * 8\narpeggios = CMaj7 + FMaj9\nsequence = Sequence(arpeggios, clock)\nfrequency = MidiNoteToFrequency(sequence)\n\noscillator = TriangleOscillator(frequency)\nrelease = Line(0.1, 0.5, 12, True)\nenvelope = ASREnvelope(0.0, 0.0, release, 1.0, clock)\nvoice = oscillator * envelope\n\npan = SineLFO(0.1667, -1.0, 1.0)\noutput = StereoPanner(voice, pan)\noutput.play()\n</code></pre>"},{"location":"library/processors/panning/stereowidth/","title":"StereoWidth node documentation","text":"<p>Reference library &gt; Processors: Panning &gt; StereoWidth</p>"},{"location":"library/processors/panning/stereowidth/#stereowidth","title":"StereoWidth","text":"<pre><code>StereoWidth(input=0, width=1)\n</code></pre> <p>Reduces the width of a stereo signal. When <code>width</code> = 1, input is unchanged. When <code>width</code> = 0, outputs a pair of identical channels both containing L+R.</p>"},{"location":"library/processors/panning/stereowidth/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using StereoWidth to continuously alter the width of a stereo signal.\n#-------------------------------------------------------------------------------\nlow = TriangleOscillator(220)\nhigh = TriangleOscillator(660)\npanned = ChannelArray([low, high])\nwidth = StereoWidth(panned, TriangleLFO(0.5, 0, 1)) * 0.3\nwidth.play()\n</code></pre>"},{"location":"library/processors/smooth/","title":"Smooth node documentation","text":"<p>Reference library &gt; Processors &gt; Smooth</p>"},{"location":"library/processors/smooth/#smooth","title":"Smooth","text":"<pre><code>Smooth(input=None, smooth=0.99)\n</code></pre> <p>Smooth the input with a given smoothing coefficient. When <code>smooth</code> = 0, applies no smoothing.</p>"},{"location":"library/processors/wetdry/","title":"WetDry node documentation","text":"<p>Reference library &gt; Processors &gt; WetDry</p>"},{"location":"library/processors/wetdry/#wetdry","title":"WetDry","text":"<pre><code>WetDry(dry_input=None, wet_input=None, wetness=0.0)\n</code></pre> <p>Takes <code>wet</code> and <code>dry</code> inputs, and outputs a mix determined by <code>wetness</code>.</p>"},{"location":"library/processors/wrap/","title":"Wrap node documentation","text":"<p>Reference library &gt; Processors &gt; Wrap</p>"},{"location":"library/processors/wrap/#wrap","title":"Wrap","text":"<pre><code>Wrap(input=None, min=-1.0, max=1.0)\n</code></pre> <p>Wrap the input beyond <code>min</code>/<code>max</code>.</p>"},{"location":"library/sequencing/","title":"Sequencing","text":"<p>Reference library &gt; Sequencing</p>"},{"location":"library/sequencing/#sequencing","title":"Sequencing","text":"<ul> <li>ClockDivider: When given a <code>clock</code> input (e.g., an Impulse), divides the clock by the given <code>factor</code>. factor must be an integer greater than or equal to 1.</li> <li>Counter: Count upwards from <code>min</code> to <code>max</code>, driven by <code>clock</code>.</li> <li>Euclidean: Euclidean rhythm as described by Toussaint, with <code>sequence_length</code> (n) and <code>num_events</code> (k), driven by <code>clock</code>.</li> <li>FlipFlop: Flips from 0/1 on each <code>clock</code>.</li> <li>ImpulseSequence: Each time a <code>clock</code> or trigger is received, outputs the next value in <code>sequence</code>. At all other times, outputs zero.</li> <li>Index: Outputs the value in <code>list</code> corresponding to <code>index</code>.</li> <li>Latch: Initially outputs 0. When a trigger is received at <code>set</code>, outputs 1. When a trigger is subsequently received at <code>reset</code>, outputs 0, until the next <code>set</code>.</li> <li>Sequence: Outputs the elements in <code>sequence</code>, incrementing position on each <code>clock</code>.</li> <li>TriggerMult: Distribute any triggers to all output nodes.</li> <li>TriggerRoundRobin: Relay trigger() events to a single node from the list of connected outputs, with <code>direction</code> determining the direction: 1 (or above) = move forwards by N, -1 = move backwards by N, 0 = stationary.</li> </ul>"},{"location":"library/sequencing/clockdivider/","title":"ClockDivider node documentation","text":"<p>Reference library &gt; Sequencing &gt; ClockDivider</p>"},{"location":"library/sequencing/clockdivider/#clockdivider","title":"ClockDivider","text":"<pre><code>ClockDivider(clock=0, factor=1)\n</code></pre> <p>When given a <code>clock</code> input (e.g., an Impulse), divides the clock by the given <code>factor</code>. factor must be an integer greater than or equal to 1.</p>"},{"location":"library/sequencing/clockdivider/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using a ClockDivider to create rhythms related to the main clock. Here the \n# oscillator panned left is heard on every tick of the clock. The oscillator \n# panned right is heard every 3 ticks of the clock.\n#-------------------------------------------------------------------------------\nclock = Impulse(2.0)\ndivided_clock = ClockDivider(clock, 3)\n\noscillator_a = TriangleOscillator(220)\noscillator_b = TriangleOscillator(440)\n\nenvelope_a = ASREnvelope(0.01, 0.0, 0.25, 1.0, clock)\nenvelope_b = ASREnvelope(0.01, 0.0, 0.5, 1.0, divided_clock)\n\nvoice_a = oscillator_a * envelope_a * 0.5\nvoice_b = oscillator_b * envelope_b * 0.5\n\nleft = StereoPanner(voice_a, -0.75)\nright = StereoPanner(voice_b, 0.75)\n\nleft.play()\nright.play()\n</code></pre>"},{"location":"library/sequencing/counter/","title":"Counter node documentation","text":"<p>Reference library &gt; Sequencing &gt; Counter</p>"},{"location":"library/sequencing/counter/#counter","title":"Counter","text":"<pre><code>Counter(clock=0, min=0, max=2147483647)\n</code></pre> <p>Count upwards from <code>min</code> to <code>max</code>, driven by <code>clock</code>.</p>"},{"location":"library/sequencing/euclidean/","title":"Euclidean node documentation","text":"<p>Reference library &gt; Sequencing &gt; Euclidean</p>"},{"location":"library/sequencing/euclidean/#euclidean","title":"Euclidean","text":"<pre><code>Euclidean(clock=0, sequence_length=0, num_events=0)\n</code></pre> <p>Euclidean rhythm as described by Toussaint, with <code>sequence_length</code> (n) and <code>num_events</code> (k), driven by <code>clock</code>.</p>"},{"location":"library/sequencing/flipflop/","title":"FlipFlop node documentation","text":"<p>Reference library &gt; Sequencing &gt; FlipFlop</p>"},{"location":"library/sequencing/flipflop/#flipflop","title":"FlipFlop","text":"<pre><code>FlipFlop(clock=0)\n</code></pre> <p>Flips from 0/1 on each <code>clock</code>.</p>"},{"location":"library/sequencing/impulsesequence/","title":"ImpulseSequence node documentation","text":"<p>Reference library &gt; Sequencing &gt; ImpulseSequence</p>"},{"location":"library/sequencing/impulsesequence/#impulsesequence","title":"ImpulseSequence","text":"<pre><code>ImpulseSequence(sequence=std::vector&lt;int&gt; ( ), clock=None)\n</code></pre> <p>Each time a <code>clock</code> or trigger is received, outputs the next value in <code>sequence</code>. At all other times, outputs zero.</p>"},{"location":"library/sequencing/index/","title":"Index node documentation","text":"<p>Reference library &gt; Sequencing &gt; Index</p>"},{"location":"library/sequencing/index/#index","title":"Index","text":"<pre><code>Index(list={}, index=0)\n</code></pre> <p>Outputs the value in <code>list</code> corresponding to <code>index</code>.</p>"},{"location":"library/sequencing/latch/","title":"Latch node documentation","text":"<p>Reference library &gt; Sequencing &gt; Latch</p>"},{"location":"library/sequencing/latch/#latch","title":"Latch","text":"<pre><code>Latch(set=0, reset=0)\n</code></pre> <p>Initially outputs 0. When a trigger is received at <code>set</code>, outputs 1. When a trigger is subsequently received at <code>reset</code>, outputs 0, until the next <code>set</code>.</p>"},{"location":"library/sequencing/sequence/","title":"Sequence node documentation","text":"<p>Reference library &gt; Sequencing &gt; Sequence</p>"},{"location":"library/sequencing/sequence/#sequence","title":"Sequence","text":"<pre><code>Sequence(sequence=std::vector&lt;float&gt; ( ), clock=None)\n</code></pre> <p>Outputs the elements in <code>sequence</code>, incrementing position on each <code>clock</code>.</p>"},{"location":"library/sequencing/sequence/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Creating a sequence using the MIDI note values of a C Major scale, starting on\n# middle C.\n#-------------------------------------------------------------------------------\nclock = Impulse(2.0)\nsequence = Sequence([ 60, 62, 64, 65, 67, 69, 71, 72 ], clock)\nfrequency = MidiNoteToFrequency(sequence)\noscillator = TriangleOscillator(frequency)\noscillator.play()\n</code></pre>"},{"location":"library/sequencing/triggermult/","title":"TriggerMult node documentation","text":"<p>Reference library &gt; Sequencing &gt; TriggerMult</p>"},{"location":"library/sequencing/triggermult/#triggermult","title":"TriggerMult","text":"<pre><code>TriggerMult(a=0)\n</code></pre> <p>Distribute any triggers to all output nodes.</p>"},{"location":"library/sequencing/triggerroundrobin/","title":"TriggerRoundRobin node documentation","text":"<p>Reference library &gt; Sequencing &gt; TriggerRoundRobin</p>"},{"location":"library/sequencing/triggerroundrobin/#triggerroundrobin","title":"TriggerRoundRobin","text":"<pre><code>TriggerRoundRobin(direction=1)\n</code></pre> <p>Relay trigger() events to a single node from the list of connected outputs, with <code>direction</code> determining the direction: 1 (or above) = move forwards by N, -1 = move backwards by N, 0 = stationary.</p>"},{"location":"library/stochastic/","title":"Stochastic","text":"<p>Reference library &gt; Stochastic</p>"},{"location":"library/stochastic/#stochastic","title":"Stochastic","text":"<ul> <li>Logistic: Logistic noise.</li> <li>PinkNoise: Pink noise, with specified low/high cutoffs.</li> <li>RandomBrownian: Outputs Brownian noise between min/max, with a mean change of delta between samples. If a clock is passed, only generates a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomChoice: Pick a random value from the given array. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomCoin: Flip a coin with the given probability. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomExponentialDist: Generate an random value following the exponential distribution. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomExponential: Generate an random exponential value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomGaussian: Generate an random Gaussian value, with given mean and sigma. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>RandomImpulseSequence: Generates a random sequence of 0/1 bits with the given length, and the given probability each each bit = 1. The position of the sequence is incremented on each clock signal. explore and generate are trigger inputs which cause the sequence to mutate and re-generate respectively.</li> <li>RandomImpulse: Generate random impulses at the given frequency, with either uniform or poisson distribution.</li> <li>RandomUniform: Generates a uniformly random value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</li> <li>WhiteNoise: Generates whitenoise between min/max. If frequency is zero, generates at audio rate. For frequencies lower than audio rate, interpolate applies linear interpolation between values, and random_interval specifies whether new random values should be equally-spaced or randomly-spaced.</li> </ul>"},{"location":"library/stochastic/logistic/","title":"Logistic node documentation","text":"<p>Reference library &gt; Stochastic &gt; Logistic</p>"},{"location":"library/stochastic/logistic/#logistic","title":"Logistic","text":"<pre><code>Logistic(chaos=3.7, frequency=0.0)\n</code></pre> <p>Logistic noise.</p>"},{"location":"library/stochastic/pinknoise/","title":"PinkNoise node documentation","text":"<p>Reference library &gt; Stochastic &gt; PinkNoise</p>"},{"location":"library/stochastic/pinknoise/#pinknoise","title":"PinkNoise","text":"<pre><code>PinkNoise(low_cutoff=20.0, high_cutoff=20000.0, reset=None)\n</code></pre> <p>Pink noise, with specified low/high cutoffs.</p>"},{"location":"library/stochastic/randombrownian/","title":"RandomBrownian node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomBrownian</p>"},{"location":"library/stochastic/randombrownian/#randombrownian","title":"RandomBrownian","text":"<pre><code>RandomBrownian(min=-1.0, max=1.0, delta=0.01, clock=None, reset=None)\n</code></pre> <p>Outputs Brownian noise between min/max, with a mean change of delta between samples. If a clock is passed, only generates a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomchoice/","title":"RandomChoice node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomChoice</p>"},{"location":"library/stochastic/randomchoice/#randomchoice","title":"RandomChoice","text":"<pre><code>RandomChoice(values=std::vector&lt;float&gt; ( ), clock=None, reset=None)\n</code></pre> <p>Pick a random value from the given array. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomcoin/","title":"RandomCoin node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomCoin</p>"},{"location":"library/stochastic/randomcoin/#randomcoin","title":"RandomCoin","text":"<pre><code>RandomCoin(probability=0.5, clock=None, reset=None)\n</code></pre> <p>Flip a coin with the given probability. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomexponential/","title":"RandomExponential node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomExponential</p>"},{"location":"library/stochastic/randomexponential/#randomexponential","title":"RandomExponential","text":"<pre><code>RandomExponential(min=0.001, max=1.0, clock=None, reset=None)\n</code></pre> <p>Generate an random exponential value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomexponentialdist/","title":"RandomExponentialDist node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomExponentialDist</p>"},{"location":"library/stochastic/randomexponentialdist/#randomexponentialdist","title":"RandomExponentialDist","text":"<pre><code>RandomExponentialDist(scale=0.0, clock=None, reset=None)\n</code></pre> <p>Generate an random value following the exponential distribution. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomgaussian/","title":"RandomGaussian node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomGaussian</p>"},{"location":"library/stochastic/randomgaussian/#randomgaussian","title":"RandomGaussian","text":"<pre><code>RandomGaussian(mean=0.0, sigma=0.0, clock=None, reset=None)\n</code></pre> <p>Generate an random Gaussian value, with given mean and sigma. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/randomimpulse/","title":"RandomImpulse node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomImpulse</p>"},{"location":"library/stochastic/randomimpulse/#randomimpulse","title":"RandomImpulse","text":"<pre><code>RandomImpulse(frequency=1.0, distribution=SIGNALFLOW_EVENT_DISTRIBUTION_UNIFORM, reset=None)\n</code></pre> <p>Generate random impulses at the given frequency, with either uniform or poisson distribution.</p>"},{"location":"library/stochastic/randomimpulsesequence/","title":"RandomImpulseSequence node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomImpulseSequence</p>"},{"location":"library/stochastic/randomimpulsesequence/#randomimpulsesequence","title":"RandomImpulseSequence","text":"<pre><code>RandomImpulseSequence(probability=0.5, length=8, clock=None, explore=None, generate=None, reset=None)\n</code></pre> <p>Generates a random sequence of 0/1 bits with the given length, and the given probability each each bit = 1. The position of the sequence is incremented on each clock signal. explore and generate are trigger inputs which cause the sequence to mutate and re-generate respectively.</p>"},{"location":"library/stochastic/randomuniform/","title":"RandomUniform node documentation","text":"<p>Reference library &gt; Stochastic &gt; RandomUniform</p>"},{"location":"library/stochastic/randomuniform/#randomuniform","title":"RandomUniform","text":"<pre><code>RandomUniform(min=0.0, max=1.0, clock=None, reset=None)\n</code></pre> <p>Generates a uniformly random value between min/max. If a clock is passed, only picks a new value on a clock tick. To generate and hold an unchanging random value, pass clock=0.</p>"},{"location":"library/stochastic/whitenoise/","title":"WhiteNoise node documentation","text":"<p>Reference library &gt; Stochastic &gt; WhiteNoise</p>"},{"location":"library/stochastic/whitenoise/#whitenoise","title":"WhiteNoise","text":"<pre><code>WhiteNoise(frequency=0.0, min=-1.0, max=1.0, interpolate=true, random_interval=true, reset=None)\n</code></pre> <p>Generates whitenoise between min/max. If frequency is zero, generates at audio rate. For frequencies lower than audio rate, interpolate applies linear interpolation between values, and random_interval specifies whether new random values should be equally-spaced or randomly-spaced.</p>"},{"location":"library/stochastic/whitenoise/#examples","title":"Examples","text":"<pre><code>#-------------------------------------------------------------------------------\n# Using white noise to control the pitch of an oscillator.\n# A new pitch is determined once every second. Interpolation is turned off so \n# that the oscillator jumps to the new pitch instead of smoothly moving to it.\n# Random interval is turned off so that pitch changes occur at a regular rate.\n#-------------------------------------------------------------------------------\nfrequency = WhiteNoise( frequency=1,\n                        min=100, \n                        max=1000, \n                        interpolate=False, \n                        random_interval=False)\noscillator = SineOscillator(frequency)\noutput = StereoPanner(oscillator) * 0.5\noutput.play()\n</code></pre> <pre><code>#-------------------------------------------------------------------------------\n# Using white noise to simulate the sound of wind.\n# White noise is generated at audio rate and passed into a band-pass filter.\n# The cutoff of the filter is controlled by another white noise generator, which\n# generates a new value between 100 and 300 at randomly-spaced intervals every \n# second, and smoothly interpolates between these values.\n#-------------------------------------------------------------------------------\nnoise = WhiteNoise()\ncutoff = WhiteNoise(1, 100, 300, True, True)\nfiltered = SVFilter(input=noise,\n                    filter_type= \"band_pass\", \n                    cutoff=cutoff,\n                    resonance=0.8)\noutput = StereoPanner(filtered) * 0.5\noutput.play()\n</code></pre>"},{"location":"node/","title":"Nodes","text":"<p>A <code>Node</code> object is an audio processing unit that performs one single function. For example, a Node's role may be to synthesize a waveform, read from a buffer, or take two input Nodes and sum their values.</p> <ul> <li>Nodes are played and stopped by connecting them to the AudioGraph </li> <li>A node has one or more audio-rate inputs, which can be modulated by other nodes \u2014 for example, a filter node has inputs for <code>cutoff</code> and <code>resonance</code> </li> <li>Some nodes can be triggered with trigger inputs \u2014 for example, to restart playback, or set the position of an envelope</li> <li>Some nodes can be used to play back the contents of buffer inputs, or can use buffer data as a source of modulation \u2014 for example, the <code>Granulator</code> node plays grains of audio from one buffer, and takes another buffer to shape the envelope of each grain</li> <li>The output of multiple nodes can be combined and modulated with use of the standard Python operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>%</code>, etc)</li> <li>The output of a node can be mono (single-channel) or multichannel</li> <li>A Node's status and output can be examined by querying its properties</li> <li>Some Nodes generate unpredictable stochastic output, which can be controlled via its internal random number generator </li> <li>Details of how to create a new Node type are detailed in Developing a new Node class</li> </ul> <p>For an overview of every type of Node available in SignalFlow, see the Node Reference Library</p> <p>\u2192 Next: Node playback</p>"},{"location":"node/developing/","title":"Nodes","text":""},{"location":"node/developing/#developing-new-node-classes","title":"Developing new Node classes","text":"<p>See CONTRIBUTING.md</p>"},{"location":"node/inputs/","title":"Nodes","text":""},{"location":"node/inputs/#node-inputs","title":"Node inputs","text":"<p>A node has three different classes of input:</p> <ul> <li>Audio-rate inputs: Takes the output of another node as an input, for continuous modulation of synthesis parameters</li> <li>Trigger inputs: Used to trigger discrete control events \u2014 for example, restarting buffer playback</li> <li>Buffer inputs: Used to pass the contents of an audio buffer to a node \u2014 for example, as a source of audio samples, or an envelope shape</li> </ul>"},{"location":"node/inputs/#audio-rate-inputs","title":"Audio-rate inputs","text":"<p>Virtually every node has one or more audio-rate inputs. Put simply, an audio-rate input is the output of another node. Let's look at a short example:</p> <pre><code>lfo = SineLFO()\nsignal = SquareOscillator(frequency=200, width=lfo)\n</code></pre> <p>In this case, we are passing the output of a <code>SineLFO</code> as the pulse width of a <code>SquareOscillator</code>. This is an audio-rate input.</p> <p>Although it's not obvious, the <code>frequency</code> parameter is also an audio-rate input. Any constant value (such as the <code>200</code> here) is behind the scenes implemented as a <code>Constant</code> node, which continuously outputs the value at an audio rate.</p> <p>All audio-rate inputs can be modified just like a normal Python property. For example:</p> <pre><code>signal.frequency = TriangleOscillator(0.5, 100, 1000)\n</code></pre>"},{"location":"node/inputs/#variable-input-nodes","title":"Variable input nodes","text":"<p>Some nodes have a variable number of inputs, which can change over the Node's lifetime. For example, <code>Sum()</code> takes an arbitrary number of input Nodes, and generates an output which is the sum of all of its inputs.</p> <p>For variable-input nodes such as this, audio-rate inputs are added with <code>add_input()</code>, and can be removed with <code>remove_input()</code>.</p> <pre><code>a = Constant(1)\nb = Constant(2)\nc = Constant(3)\nsum = Sum()\nsum.add_input(a)\nsum.add_input(b)\nsum.add_input(c)\n# sum will now generate an output of 6.0\n</code></pre> <p>It is possible to check whether a Node object takes variable inputs by querying <code>node.has_variable_inputs</code>.</p>"},{"location":"node/inputs/#triggers","title":"Triggers","text":"<p>When working with sequencing and timing, it is often useful be able to trigger discrete events within a node. This is where trigger inputs come in handy.</p> <p>There are two different ways to handle trigger inputs:</p> <ul> <li>by calling the <code>trigger()</code> method on a <code>Node</code></li> <li>by passing a Node to an input that corresponds to an audio-rate trigger</li> </ul>"},{"location":"node/inputs/#calling-trigger","title":"Calling trigger()","text":"<p>To generate trigger events at arbitrary times, call <code>node.trigger()</code>. For example:</p> <pre><code>freq_env = Line(10000, 100, 0.5)\nsine = SineOscillator(freq_env)\nsine.play()\nwhile True:\n    freq_env.trigger()\n    graph.wait(1)\n</code></pre> <p>This is useful because it can be done outside the audio thread. For example, <code>trigger()</code> could be called each time a MIDI note event is received. </p> <p>The <code>trigger()</code> method takes an optional <code>name</code> parameter, which is used by <code>Node</code> classes containing more than one type of trigger. This example uses the <code>set_position</code> trigger of <code>BufferPlayer</code> to seek to a new location in the sample every second. </p> <pre><code>buffer = Buffer(\"../audio/stereo-count.wav\")\nplayer = BufferPlayer(buffer, loop=True)\nplayer.play()\nwhile True:\n    player.trigger(\"set_position\", random_uniform(0, buffer.duration))\n    graph.wait(1)\n</code></pre> <p>Note</p> <p>Because the <code>trigger</code> method happens outside the audio thread, it will take effect at the start of the next audio block. This means that, if you are running at 44.1kHz with an audio buffer size of 1024 samples, this could introduce a latency of up to <code>1024/44100 = 0.023s</code>.   For time-critical events like drum triggers, this can be minimised by reducing the hardware output buffer size.</p> <p>This constraint also means that only one event can be triggered per audio block. To trigger events at a faster rate than the hardware buffer size allows, see Audio-rate triggers below.  </p>"},{"location":"node/inputs/#audio-rate-triggers","title":"Audio-rate triggers","text":"<p>It is often desirable to trigger events using the audio-rate output of another Node object as a source of trigger events, to give sample-level precision in timing. Most nodes that support <code>trigger</code> inputs can also be triggered by a corresponding audio-rate input. </p> <p>Triggers happen at zero-crossings \u2014 that is, when the output of the node passes above zero (i.e., from <code>&lt;= 0</code> to <code>&gt;0</code>). For example, to create a clock with an oscillating tempo to re-trigger buffer playback: </p> <pre><code>clock = Impulse(SineLFO(0.2, 1, 10))\nbuffer = Buffer(\"examples/audio/stereo-count.wav\")\nplayer = BufferPlayer(buffer, loop=True, clock=clock)\nplayer.play()\n</code></pre> <p>This can be used to your advantage with the boolean operator nodes. </p> <pre><code>on_the_right = MouseX() &gt; 0.5\nenvelope = ASREnvelope(0, 0, 0.5, clock=on_the_right)\nsquare = SquareOscillator(100)\noutput = envelope * square * 0.1\noutput.play()\n</code></pre> <p>TODO: Should the name of the trigger() event always be identical to the trigger input name? So <code>clock</code> for envelopes, buffer player, etc...?</p>"},{"location":"node/inputs/#buffer-inputs","title":"Buffer inputs","text":"<p>The third type of input supported by nodes is the buffer. Nodes often take buffer inputs as sources of audio samples. They are also useful as sources of envelope shape data (for example, to shape the grains of a Granulator), or general control data (for example, recording motion patterns from a <code>MouseX</code> input).</p> <pre><code>buffer = Buffer(\"audio/stereo-count.wav\")\nplayer = BufferPlayer(buffer, loop=True)\n</code></pre> <p>A buffer input cannot be set using the same property shorthand as audio-rate inputs; instead, the <code>set_buffer</code> method should be used. </p> <pre><code>new_buffer = Buffer(\"audio/example.wav\")\nplayer.set_buffer(\"buffer\", new_buffer)\n</code></pre> <p>TODO: Should this be <code>set_input</code> for consistency with Patch?</p>"},{"location":"node/inputs/#enumerating-a-nodes-inputs","title":"Enumerating a node's inputs","text":"<p>To list the potential and actual inputs of a node, the <code>.inputs</code> property returns a <code>dict</code> of key-value pairs:</p> <pre><code>&gt;&gt;&gt; player.inputs\n{\n    'clock': &lt;signalflow.Impulse at 0x107778eb0&gt;,\n    'end_time': None,\n    'loop': &lt;signalflow.Constant at 0x12a4cd4b0&gt;,\n    'rate': &lt;signalflow.Constant at 0x12a4cd330&gt;,\n    'start_time': None\n}\n</code></pre> <p>Any constant-valued inputs are wrapped inside a special <code>Constant</code> node class. The value contained by a <code>Constant</code> can be accessed with its <code>.value</code> property.</p>"},{"location":"node/inputs/#playerinputsratevalue-10","title":"<pre><code>&gt;&gt;&gt; player.inputs[\"rate\"].value\n1.0\n</code></pre>","text":"<p>\u2192 Next: Operators</p>"},{"location":"node/multichannel/","title":"Nodes","text":""},{"location":"node/multichannel/#multichannel-nodes","title":"Multichannel nodes","text":"<p>When passing a value to audio-rate input of a Node, the signal is by default monophonic (single-channel). For example, <code>SquareOscillator(440)</code> generates a 1-channel output.</p> <p>It is possible to generate multi-channel output by passing an array of values in the place of a constant. For example, <code>SquareOscillator([440, 880])</code> generates stereo output with a different frequency in the L and R channels. </p> <p>There is no limit to the number of channels that can be generated by a node. For example, <code>SquareOscillator(list(100 + 50 * n for n in range(100)))</code> will create a node with 100-channel output, each with its own frequency. </p> <pre><code>&gt;&gt;&gt; sq = SquareOscillator([100 + 50 * n for n in range(100)])\n&gt;&gt;&gt; print(sq.num_output_channels)\n100\n</code></pre>"},{"location":"node/multichannel/#automatic-upmixing","title":"Automatic upmixing","text":"<p>There are generally multiple inputs connected to a node, which may themselves have differing number of channels. For example, <code>SquareOscillator(frequency=[100, 200, 300, 400, 500], width=0.7)</code> has a 5-channel input and a 1-channel input. In cases like this, the output of the nodes with fewer channels is upmixed to match the higher-channel inputs.</p> <p>Upmixing here means simply duplicating the output until it reaches the desired number of channels. In the above case, the <code>width</code> input will be upmixed to generate 5 channels, all containing <code>0.7</code>.</p> <p>If <code>width</code> were a stereo input with L and R channels, the output would be tiled, alternating between the channels. Each frame of stereo input would then be upmixed to contain <code>[L, R, L, R, L]</code>, where <code>L</code> and <code>R</code> are the samples corresponding to the L and R channels.</p> <p>The key rule is that, for nodes that support upmixing, the output signal has as many channels as the input signal with the highest channel count. </p> <p>This process percolates through the signal chain. For example:</p> <pre><code>SquareOscillator(frequency=SineLFO([1, 3, 5], min=440, max=880),\n                 width=SawLFO([0.5, 0.6], min=0.25, max=0.75))\n</code></pre> <ul> <li>The <code>min</code> and <code>max</code> inputs of the <code>frequency</code> LFO would be upmixed to 3 channels each</li> <li>The <code>min</code> and <code>max</code> inputs of the <code>width</code> LFO would be upmixed to 2 channels each</li> <li>Then, the output of the <code>width</code> node would be upmixed from 2 to 3 channels</li> </ul>"},{"location":"node/multichannel/#nodes-with-fixed-inputoutput-channels","title":"Nodes with fixed input/output channels","text":"<p>Some nodes have immutable numbers of input/output channels. For example:</p> <ul> <li><code>StereoPanner</code> has 1 input channel and 2 output channels</li> <li><code>StereoBalance</code> has 2 input channels and 2 output channels</li> <li><code>ChannelMixer</code> has an arbitrary number of input channels, but a fixed, user-specified number of output channels</li> </ul> <p>Even Nodes that do not have an obvious input (e.g. <code>BufferPlayer</code>) have input channels, for modulation inputs (for example, modulating the rate of the buffer).</p> <p>When two nodes are connected together with incompatible channel counts (for example, connecting a <code>StereoBalance</code> into a <code>StereoMixer</code>), an <code>InvalidChannelCountException</code> will be raised.</p>"},{"location":"node/multichannel/#the-channel-node-classes","title":"The Channel* node classes","text":"<p>There are a number of Node subclasses dedicated to channel handling.</p> <ul> <li>ChannelArray: Concatenates the channels of multiple nodes, so that calling <code>ChannelMix</code> with nodes of <code>N</code> and <code>M</code> channels will produce an output of <code>N + M</code> channels.</li> <li>ChannelMixer: Reduces or expands the number of channels by evenly spreading the audio across the output channels.</li> <li>ChannelSelect: Selects sub-channels of the input, either individually or by group. </li> </ul>"},{"location":"node/multichannel/#querying-channel-subsets-with-the-index-operator","title":"Querying channel subsets with the index operator","text":"<p>Single channels of a multi-channel node can be accessed using the index <code>[]</code> operator. For example:</p> <pre><code>square = SquareOscillator([440, 441, 442, 443])\noutput = square[0]\n# output now contains a mono output, with a frequency of 440Hz.\n</code></pre> <p>Slice syntax can be used to query multiple subchannels:</p> <pre><code>square = SquareOscillator([440, 441, 442, 880])\noutput = square[0:2]\n# now contains a two-channel square wave\n</code></pre> <p>\u2192 Next: Status and properties</p>"},{"location":"node/operators/","title":"Nodes","text":""},{"location":"node/operators/#node-operators","title":"Node operators","text":""},{"location":"node/operators/#arithmetic","title":"Arithmetic","text":"<p>The output of multiple nodes can be combined using Python's mathematical operators. For example, to sum two sine waves together to create harmonics, use the <code>+</code> operator:</p> <pre><code>output = SineOscillator(440) + SineOscillator(880)\noutput.play()\n</code></pre> <p>To modulate the amplitude of one node with another, use the <code>*</code> operator:</p> <pre><code>sine = SineOscillator(440)\nenvelope = ASREnvelope(0.1, 1, 0.1)\noutput = sine * envelope\n</code></pre> <p>You can use constant values in place of <code>Node</code> objects:</p> <pre><code>sine = SineOscillator(440)\nattenuated = sine * 0.5\n</code></pre> <p>Operators can be chained together in the normal way:</p> <pre><code># Create an envelope that rises from 0.5 to 1.0 and back to 0.5\nenv = (ASREnvelope(0.1, 1, 0.1) * 0.5) + 0.5\n</code></pre> <p>Behind the scenes, these operators are actually creating composites of <code>Node</code> subclasses. The last example could alternatively be written as:</p> <pre><code>Add(Multiply(ASREnvelope(0.1, 1, 0.1), 0.5), 0.5)\n</code></pre>"},{"location":"node/operators/#comparison","title":"Comparison","text":"<p>Comparison operators can also be used to compare two Node output values, generating a binary (1/0) output. For example:</p> <pre><code># Generates an output of 1 when the sinusoid is above 0, and 0 otherwise \nSineOscillator(440) &gt; 0\n</code></pre> <p>This can then be used as an input to other nodes. The below will generate a half-wave-rectified sine signal (that is, a sine wave with all negative values set to zero). </p> <pre><code>sine = SineOscillator(440)\nrectified = sine * (sine &gt; 0)\n</code></pre>"},{"location":"node/operators/#index-of-operators","title":"Index of operators","text":"<p>Below is a full list of operators supported by SignalFlow.</p>"},{"location":"node/operators/#arithmetic-operators","title":"Arithmetic operators","text":"Operator Node class <code>+</code> Add <code>-</code> Subtract <code>*</code> Multiply <code>/</code> Divide <code>**</code> Power <code>%</code> Modulo"},{"location":"node/operators/#comparison-operators","title":"Comparison operators","text":"Operator Node class <code>==</code> Equal <code>!=</code> NotEqual <code>&lt;</code> LessThan <code>&lt;=</code> LessThanOrEqual <code>&gt;</code> GreaterThan <code>&gt;=</code> GreaterThanOrEqual <p>\u2192 Next: Multichannel</p>"},{"location":"node/playback/","title":"Nodes","text":""},{"location":"node/playback/#playing-and-stopping-a-node","title":"Playing and stopping a node","text":""},{"location":"node/playback/#starting-playback","title":"Starting playback","text":"<p>To start a node playing, simply call the <code>play()</code> method:</p> <pre><code>graph = AudioGraph()\nnode = SineOscillator(440)\nnode.play()\n</code></pre> <p>This connects the node to the <code>output</code> endpoint of the current global <code>AudioGraph</code>. The next time the graph processes a block of samples, the graph's <code>output</code> node then calls upon the sine oscillator to generate a block.</p> <p>It is important to remember that playing a node means \"connecting it to the graph\". For this reason, it is not possible to play the same node more than once, as it is already connected to the graph. To play multiples of a particular Node type, simply create and play multiple instances.</p>"},{"location":"node/playback/#connecting-a-node-to-another-nodes-input","title":"Connecting a Node to another Node's input","text":"<p>It is often the case that you want to connect a Node to the input of another Node for playback, rather than simply wiring it to the output of a graph -- for example, to pass an oscillator through a processor. In this case, you do not need to call <code>play()</code> (which means \"connect this node to the graph\"). Instead, it is sufficient to simply connect the Node to the input of another Node that is already playing.</p> <p>For example:</p> <pre><code># create and begin playback of a variable input summer, passed through a filter\nsum = Sum()\nflt = SVFilter(sum, \"low_pass\", 200)\nflt.play()\n</code></pre> <p>Now, let's create an oscillator. Observe that connecting the oscillator to the filter's input begins playback immediately.</p> <pre><code>square = SquareOscillator(100)\nsum.add_input(square)\n</code></pre>"},{"location":"node/playback/#stopping-playback","title":"Stopping playback","text":"<p>To stop a node playing:</p> <pre><code>node.stop()\n</code></pre> <p>This disconnects the node from the output device that it is connected to. </p> <p>\u2192 Next: Inputs</p>"},{"location":"node/properties/","title":"Nodes","text":""},{"location":"node/properties/#node-properties","title":"Node properties","text":"<p>A <code>Node</code> has a number of read-only properties which can be used to query its status at a given moment in time.</p> Property Type Description name str Short alphanumeric string that identifies the type of node (for example, <code>asr-envelope</code>) num_output_channels int The number of output channels that the node generates. num_input_channels int The number of input channels that the node takes. Note that most nodes have <code>matches_input_channels</code> set, meaning that their <code>num_input_channels</code> will be automatically increased according to their inputs. To learn more, see Nodes: Multichannel. matches_input_channels bool Whether the node automatically increases its <code>num_input_channels</code> based on its inputs. To learn more, see Nodes: Multichannel. has_variable_inputs bool Whether the node supports an arbitrary number of audio-rate inputs output_buffer numpy.ndarray Contains the Node's most recent audio output, in <code>float32</code> samples. The buffer is indexed by <code>channel</code> x <code>frame</code>, so to obtain the 32nd sample in the first channel, query: <code>node.output_buffer[0][31]</code>. inputs dict A dict containing all of the <code>Node</code>'s audio-rate inputs. Note that buffer inputs are not currently included within this dict. state int The Node's current playback state, which can be one of <code>SIGNALFLOW_NODE_STATE_ACTIVE</code> and <code>SIGNALFLOW_NODE_STATE_STOPPED</code>. The <code>STOPPED</code> state only applies to those nodes which have a finite duration (e.g. <code>ASREnvelope</code>, or <code>BufferPlayer</code> with looping disabled) and have reached the end of playback. Nodes continue to have a state of <code>ACTIVE</code> whether or not they are connected to the graph. patch Patch Indicates the Patch that the node is part of, or None if the Node does not belong to a Patch."},{"location":"node/properties/#monitoring-a-nodes-output","title":"Monitoring a node's output","text":"<p>To monitor the output of a node, call <code>node.poll(num_seconds)</code>, where <code>num_seconds</code> is the interval between messages. This will print the last sample generated by the node to <code>stdout</code>. In the case of multichannel nodes, only the first channel's value is printed.</p> <pre><code>&gt;&gt;&gt; a = Counter(Impulse(1))\n&gt;&gt;&gt; a.poll(1)\n&gt;&gt;&gt; a.play()\ncounter: 0.00000\ncounter: 1.00000\ncounter: 2.00000\n</code></pre> <p>To stop polling a node, call <code>node.poll(0)</code>.</p>"},{"location":"node/properties/#node-specific-properties","title":"Node-specific properties","text":"<p>Some <code>Node</code> classes have additional properties, containing information on implementation-specific states. These can be accessed via the <code>get_property</code> method.</p> <p>For example, the <code>BufferPlayer</code> node exposes a <code>position</code> property, which returns the playhead's current position, in seconds.</p> <pre><code>&gt;&gt;&gt; buffer = Buffer(\"audio.wav\")\n&gt;&gt;&gt; player = BufferPlayer(buffer)\n&gt;&gt;&gt; player.play()\n...\n&gt;&gt;&gt; player.get_property(\"position\")\n5.984000205993652\n</code></pre> <p>\u2192 Next: Stochastic nodes</p>"},{"location":"node/stochastic/","title":"Nodes","text":""},{"location":"node/stochastic/#chance-and-stochastic-nodes","title":"Chance and stochastic nodes","text":"<p>SignalFlow has a number of stochastic nodes, which make use of a pseudo-random number generator (RNG) to produce unpredictable output values.</p> <p>Each object of these <code>StochasticNode</code> subclasses stores its own RNG. By default, the RNG is seeded with a random value, so that each run will generate a different set of outputs. However, to create a repeatable pseudo-random output, the <code>seed</code> of the node's RNG can be set to a known value:</p> <pre><code>&gt;&gt;&gt; r = RandomUniform(0, 1)\n&gt;&gt;&gt; r.process(1024)\n&gt;&gt;&gt; r.output_buffer[0][:4]\narray([0.48836085, 0.64326525, 0.79819506, 0.8489549 ], dtype=float32)\n&gt;&gt;&gt; r.set_seed(123)\n&gt;&gt;&gt; r.process(1024)\n&gt;&gt;&gt; r.output_buffer[0][:4]\narray([0.7129553 , 0.42847094, 0.6908848 , 0.7191503 ], dtype=float32)\n&gt;&gt;&gt; r.set_seed(123)\n&gt;&gt;&gt; r.process(1024)\n&gt;&gt;&gt; r.output_buffer[0][:4]\narray([0.7129553 , 0.42847094, 0.6908848 , 0.7191503 ], dtype=float32)\n</code></pre> <p>Note the identical sequences generated after repeatedly setting the seed to a known value. </p> <p>Warning</p> <p>Calling <code>node.process()</code> is generally not good practice, as it does not recursively process all of the node's inputs (unlike when a node is embedded within an AudioGraph, which correctly handles recursion and cyclical loops). Please use at your peril!</p> <p>\u2192 Next: Node reference library</p>"},{"location":"patch/","title":"Patch","text":"<p>Warning</p> <p>This documentation is a work-in-progress and may have sections that are missing or incomplete.</p> <p>A <code>Patch</code> represents a connected group of <code>Nodes</code>, analogous to a synthesizer. Defining patches makes it easy to create higher-level structures, which can then be reused and instantiated with a single line of code, in much the same way as a Node.</p> <p>Behind the scenes, the structure of a <code>Patch</code> is encapsulated by a <code>PatchSpec</code>, a template which can be instantiated or serialised to a JSON file for later use.  </p> <ul> <li>A Patch structure is defined either by declaring a Patch subclass or with a JSON specification file</li> <li>Play and stop a Patch by connecting it to the AudioGraph or the input of another Patch or Node </li> <li>Similar to nodes, a Patch can be modulated by audio-rate inputs, triggered by trigger inputs, and access sample data via buffer inputs </li> <li>The outputs of Patches can be altered or combined by normal Python operators</li> <li>The status of a Patch can be queried via its properties </li> <li>Patches can be exported and imported to JSON</li> <li>The auto-free mechanism allows Patches to automatically stop and free their memory after playback is complete </li> </ul> <p>\u2192 Next: Defining a Patch</p>"},{"location":"patch/auto-free/","title":"Patch","text":""},{"location":"patch/auto-free/#auto-free-and-memory-management","title":"Auto-free and memory management","text":"<p>Auto-free.</p>"},{"location":"patch/defining/","title":"Patch","text":""},{"location":"patch/defining/#defining-a-patch","title":"Defining a Patch","text":"<p>A Patch is made up of a connected network of Nodes, together with a set of properties that determine how the Patch can be controlled.</p> <p>There are two general ways to define the structure of a Patch:</p> <ul> <li>Create a new class that subclasses <code>Patch</code>. In general, this is the recommended approach for defining new Patches.</li> <li>Create a JSON file that can be loaded as a <code>PatchSpec</code>, which describes the structure of a patch </li> </ul>"},{"location":"patch/defining/#creating-a-patch-subclass","title":"Creating a Patch subclass","text":"<p>The quickest and most intuitive way to define a <code>Patch</code> is by subclassing the <code>Patch</code> class itself. Let's look at an example.</p> <pre><code>class Bleep (Patch):\n    def __init__(self, frequency=880, duration=0.1):\n        super().__init__()\n        frequency = self.add_input(\"frequency\", frequency)\n        duration = self.add_input(\"duration\", duration)\n        sine = SineOscillator(frequency)\n        env = ASREnvelope(0.001, duration, 0.001)\n        output = sine * env\n        self.set_output(output)\n        self.set_auto_free(True)\n</code></pre> <p>In the above example:</p> <ul> <li>At the very start of the <code>__init__</code> function, <code>super().__init__()</code> must be called to initialise the Patch and its storage. This is vital! Without it, your program will crash. </li> <li>Two audio-rate input parameters are defined. The <code>add_input()</code> method is used to define them as inputs of the <code>Patch</code>, which can then be subsequently modulated. Note that the <code>add_input()</code> method returns a reference to the frequency node, which then acts as a pointer to the input node.</li> <li><code>self.set_output()</code> is used to define the Patch's output. A Patch can only have one single output.</li> <li>Finally, <code>self.set_auto_free()</code> is used to automatically stop and free the Patch after playback of the envelope is completed. More about auto-free... </li> </ul> <p>You can now instantiate a <code>Bleep</code> object in just the same way as you would instantiate and play a Node:</p> <pre><code>b = Bleep(frequency=440, duration=0.2)\nb.play()\n</code></pre> <p>If you query <code>graph.status</code> after playback has finished, you should see that the <code>Patch</code> is automatically freed and the number of nodes returns to 0. </p>"},{"location":"patch/defining/#creating-a-patchspec-from-json","title":"Creating a PatchSpec from JSON","text":"<p>The structure of a <code>Patch</code> is described by a <code>PatchSpec</code>, which can in turn be imported/exported in the JSON text-based data interchange format. </p> <p>For information on loading or saving PatchSpecs as JSON, see Exporting and importing patches.</p> <p>\u2192 Next: Playing and stopping a Patch</p>"},{"location":"patch/exporting/","title":"Patch","text":""},{"location":"patch/exporting/#exporting-and-importing-patches","title":"Exporting and importing patches","text":"<p>A Patch can be exported or imported.</p> <p>\u2192 Next: Auto-free and memory management</p>"},{"location":"patch/inputs/","title":"Patch","text":""},{"location":"patch/inputs/#patch-inputs","title":"Patch inputs","text":"<p>Just like a Node, a Patch supports three different classes of input:</p> <ul> <li>Audio-rate inputs: Takes the output of another Node or Patch as an input, for continuous modulation of synthesis parameters</li> <li>Trigger inputs: Used to trigger discrete control events \u2014 for example, restarting buffer playback</li> <li>Buffer inputs: Used to pass the contents of an audio buffer to a patch \u2014 for example, as a source of audio samples, or an envelope shape</li> </ul>"},{"location":"patch/inputs/#audio-rate-inputs","title":"Audio-rate inputs","text":"<p>A Patch supports any number of user-defined named inputs, which can be used to modulate the nodes within the patch.</p> <p>Each input must be defined by calling <code>add_input()</code> when the Patch is first defined, with an optional default value.</p> <p>Info</p> <p>Note that Patches do not yet support variable inputs.</p> <p>When a Patch is playing, the value of its inputs can be set using <code>patch.set_input()</code>:</p> <pre><code>class Bloop (Patch):\n    def __init__(self, frequency=880, duration=0.1):\n        super().__init__()\n        frequency = self.add_input(\"frequency\", frequency)\n        sine = SineOscillator(frequency)\n        self.set_output(sine)\n        self.set_auto_free(True)\n\nbloop = Bloop()\nbloop.play()\n...\nbloop.set_input(\"frequency\", 100)\n</code></pre> <p>Info</p> <p>Note that Patches do not yet support setting inputs with Python properties (e.g. <code>patch.prop_name = 123</code>), as is possible with node inputs.</p>"},{"location":"patch/inputs/#triggers","title":"Triggers","text":"<p>When defining a <code>Patch</code>, it is possible to define which Node should receive <code>trigger()</code> events sent to the Patch. This is done with <code>patch.set_trigger_node()</code>:</p> <pre><code>class Hat (Patch):\n    def __init__(self, duration=0.1):\n        super().__init__()\n        duration = self.add_input(\"duration\", duration)\n        noise = WhiteNoise()\n        env = ASREnvelope(0.0001, 0.0, duration, curve=2)\n        output = noise * env\n        self.set_trigger_node(env)\n        self.set_output(output)\n\nh = Hat()\nh.play()\n...\nh.trigger() # triggers a hit, resetting the ASREnvelope to its start point\n</code></pre> <p>This can be used to create a <code>Patch</code> that stays connected to the AudioGraph and can be retriggered to play a hit.</p> <p>Info</p> <p>Note that Patches only presently support trigger events directed to a single node within the patch, and cannot route triggers to multiple different nodes.</p>"},{"location":"patch/inputs/#buffer-inputs","title":"Buffer inputs","text":"<p>Buffer inputs can be declared at define time by calling <code>self.add_buffer_input()</code>. Similar to <code>add_input</code>, the return value is a placeholder <code>Buffer</code> that can be used wherever you would normally pass a <code>Buffer</code>:</p> <pre><code>class WobblyPlayer (Patch):\n    def __init__(self, buffer):\n        super().__init__()\n        buffer = self.add_buffer_input(\"buffer\", buffer)\n        rate = SineLFO(0.2, 0.5, 1.5)\n        player = BufferPlayer(buffer, rate=rate, loop=True)\n        self.set_output(player)\n\nbuffer = Buffer(\"examples/audio/stereo-count.wav\")\nplayer = WobblyPlayer(buffer)\nplayer.play()\n</code></pre> <p>The buffer can then be replaced at runtime by calling <code>set_input()</code>:</p> <pre><code>player.set_input(\"buffer\", another_buffer)\n</code></pre> <p>\u2192 Next: Operators</p>"},{"location":"patch/operators/","title":"Patch","text":""},{"location":"patch/operators/#operators","title":"Operators","text":"<p>The output of a Patch can be amplified, attenuated, combined, modulated and compared using Python operators, in much the same way as Node:</p> <pre><code>patch = Patch(patch_spec)\noutput = patch * 0.5\n</code></pre> <p>For a full list of the operators that can be applied to a <code>Patch</code>, see Node operators.</p> <p>\u2192 Next: Patch properties</p>"},{"location":"patch/playback/","title":"Patch","text":""},{"location":"patch/playback/#playing-a-patch","title":"Playing a Patch","text":"<p>Once a <code>Patch</code> has been defined or imported, it can be instantiated in two different ways depending on how it was defined:</p> <ul> <li>From a Patch subclass</li> <li>From a PatchSpec</li> </ul>"},{"location":"patch/playback/#from-a-patch-subclass","title":"From a Patch subclass","text":"<p>The simplest way to instantiate a Patch is by defining it as a Patch subclass, and then instantiating it in the same way as a Node. </p> <pre><code>class Hat (Patch):\n    def __init__(self, duration=0.1):\n        super().__init__()\n        duration = self.add_input(\"duration\", duration)\n        noise = WhiteNoise()\n        env = ASREnvelope(0.0001, 0.0, duration, curve=2)\n        output = noise * env\n        self.set_output(output)\n        self.set_auto_free(True)\n\nhat = Hat()\nhat.play()\n</code></pre> <p>Once a Patch has finished, its state changes to <code>SIGNALFLOW_PATCH_STATE_STOPPED</code>.</p> <p>Just as with nodes, it is important to remember that playing a patch means \"connecting it to the graph\". For this reason, it is not possible to play the same patch more than once, as it is already connected to the graph.</p> <p>To play multiples of a particular <code>Patch</code> type, simply create and play multiple instances.</p>"},{"location":"patch/playback/#from-a-patchspec","title":"From a PatchSpec","text":"<p>Once a <code>PatchSpec</code> has been created or imported, it can be played by instantiating a <code>Patch</code> with the <code>PatchSpec</code> as an argument:</p> <pre><code>patch = Patch(patch_spec)\npatch.play()\n</code></pre>"},{"location":"patch/playback/#connecting-a-patch-to-another-patchs-input","title":"Connecting a Patch to another Patch's input","text":"<p>A <code>Patch</code> can be connected to the input of another <code>Patch</code> (or Node), in exactly the same way described in Connecting a Node to another Node's input.</p> <p>Once you have got to grips with this paradigm, it becomes simple to build up sophisticated processing graphs by abstracting complex functionality within individual <code>Patch</code> objects, and connecting them to one another. </p>"},{"location":"patch/playback/#stopping-a-patch","title":"Stopping a Patch","text":"<p>As in Node playback, stopping a Patch disconnects it from the AudioGraph. Patches with auto-free are automatically stopped when their lifetimes ends. Patches with an unlimited lifespan must be stopped manually, with:</p> <pre><code>patch.stop()\n</code></pre> <p>This disconnects the Patch from its output.</p> <p>\u2192 Next: Patch inputs</p>"},{"location":"patch/properties/","title":"Patch","text":""},{"location":"patch/properties/#patch-properties","title":"Patch properties","text":"Property Type Description nodes list A list of all of the Node objects that make up this Patch inputs dict A dict of key-value pairs corresponding to all of the (audio rate) inputs within the Patch state int The Patch's current playback state, which can be <code>SIGNALFLOW_PATCH_STATE_ACTIVE</code> or <code>SIGNALFLOW_PATCH_STATE_STOPPED</code>. graph AudioGraph A reference to the AudioGraph that the Patch is part of <p>\u2192 Next: Exporting and importing patches</p>"},{"location":"planning/EXAMPLES/","title":"Examples","text":"<p>[ ] Add signalflow-audio repo</p> <p>[x] Hello world [x] Granular [ ] Additive synthesis [ ] FM synthesis [ ] Multichannel expansion (supersaw) [ ] Stochastic  [ ] Filter [ ] Audio input [ ] Waveshaper / Clip / Fold [ ] Wavetable [x] 2D wavetable [ ] Buffer: Play [ ] Buffer: Record [ ] FFT: Tonality [ ] FFT: Convolution reverb [ ] Patch: Simple</p> <p>[ ] Control: Mouse control</p>"},{"location":"planning/NAMING/","title":"NAMING","text":""},{"location":"planning/NAMING/#nodes","title":"NODES","text":"<p>Generators  - Oscillators    - Wavetable    - Waveforms (all wrappers around Wavetable with band-limiting)      - SineOscillator      - SquareOscillator      - TriangleOscillator      - SawOscillator  - LFO (all wrappers around Wavetable)    - SineLFO    - SquareLFO    - TriangleLFO    - SawLFO  - Buffer    - BufferPlayer    - BufferRecorder  - Stochastic    -  Processors  - Panners    - ChannelMixer    - LinearPanner    - AzimuthPanner    - ObjectPanner  - Delay    - AllpassDelay    - Delay  - Effects    - EQ    - Gate    - Resampler    - Waveshaper</p> <p>Stochastic  - Random signal generators    - WhiteNoise    - PinkNoise     - BrownNoise    - PerlinNoise  - Random number generators (with clocked inputs)    - RandomUniform    - RandomLinear    - RandomBrownian    - RandomExponentialDist    - RandomGaussian    - RandomBeta  - Random event generators    - RandomImpulse</p> <p>-- PATCHES  - Patch  - PatchDef</p>"},{"location":"planning/PLAN/","title":"PLAN","text":"<p>Documentation writing guide -  https://numpy.org/numpy-tutorials/content/tutorial-style-guide.html</p> <p>References: https://tidalcycles.org/docs/ https://pradyunsg.me/furo/quickstart/</p> <ul> <li>Tutorials</li> <li>Topics</li> <li>Interactive sound design</li> <li>Sequencing and composition</li> <li>Live coding</li> <li>Controls and GUI</li> <li>MIDI control</li> <li>Offline processing</li> <li>Panning and spatial audio</li> <li>Spectral processing with FFT nodes</li> <li>Sonification</li> <li>Algorithmic composition</li> <li>Sequencing (using isobar)</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#exceptions","title":"Exceptions","text":"<ul> <li>InsufficientBufferSizeException</li> <li>DeviceNotFoundException</li> <li>NodeNotPlayingException</li> <li>NodeAlreadyPlayingException</li> </ul>"},{"location":"troubleshooting/device_not_found_exception/","title":"Troubleshooting: DeviceNotFoundException","text":""},{"location":"troubleshooting/device_not_found_exception/#example","title":"Example","text":"<pre><code>signalflow.DeviceNotFoundException: Could not find device name: Scarlett 2i2\n</code></pre>"},{"location":"troubleshooting/device_not_found_exception/#description","title":"Description","text":"<p>This exception occurs because the audio device specified in the configuration could not be found, or no audio devices at all could be found.     </p>"},{"location":"troubleshooting/device_not_found_exception/#solution","title":"Solution","text":"<p>Check that the device name that you have selected exists, and is connected to your computer and powered on.</p> <ul> <li>SignalFlow selects its output device based on the device that you have selected in your <code>~/.signalflow/config</code>, in the environmental variable <code>SIGNALFLOW_OUTPUT_DEVICE_NAME</code> (or <code>SIGNALFLOW_INPUT_DEVICE_NAME</code> for input devices), or in the <code>config</code> property passed to the <code>AudioGraph</code></li> <li>A list of all available devices can be found by running the terminal command <code>signalflow list-output-device-names</code> <pre><code>[audio]\noutput_buffer_size = 8192\n</code></pre></li> </ul>"},{"location":"troubleshooting/installation/","title":"Troubleshooting: Installation problems","text":""},{"location":"troubleshooting/installation/#general-python-installation-guidelines","title":"General Python installation guidelines","text":"<ul> <li>It is generally best to use a version of Python that is separate from the system Python, using an installer from Python.org or a package manager such as Homebrew.</li> <li>To minimise conflicts with other software, you should also ideally create a Python virtual environment, which is outlined in the easy installation guide.</li> </ul>"},{"location":"troubleshooting/installation/#on-macos","title":"On macOS","text":"<p>Note that macOS 10.15 (Catalina) or above is required.</p>"},{"location":"troubleshooting/installation/#on-linux","title":"On Linux","text":"<p>If you are having audio problems with Linux, try switching to a different audio backend. From the command-line, run:</p> <pre><code>signalflow list-backend-names\n</code></pre> <p>Then, run <code>signalflow config</code>, and add a line to select an alternative backend:</p> <pre><code>[audio]\noutput_backend_name = \"pulseaudio\"\n</code></pre>"},{"location":"troubleshooting/installation/#on-raspberry-pi","title":"On Raspberry Pi","text":"<p>SignalFlow requires Raspberry Pi 3 Model B or above. Note that only 64-bit devices and operating systems are supported (<code>uname -m</code> should display <code>aarch64</code>). </p>"},{"location":"troubleshooting/insufficient_buffer_size_exception/","title":"Troubleshooting: InsufficientBufferSizeException","text":""},{"location":"troubleshooting/insufficient_buffer_size_exception/#example","title":"Example","text":"<pre><code>Exception in AudioGraph: Node audioout-soundio cannot render because output\nbuffer size is insufficient (8192 samples requested, buffer size = 2048).\nIncrease the buffer size.\n</code></pre>"},{"location":"troubleshooting/insufficient_buffer_size_exception/#description","title":"Description","text":"<p>This exception occurs because the audio hardware is requesting more samples than a node has currently allocated. This allocation is controlled by SignalFlow's <code>output_buffer_size</code> config parameter.   </p>"},{"location":"troubleshooting/insufficient_buffer_size_exception/#solution","title":"Solution","text":"<p>Increase the <code>output_buffer_size</code> within your SignalFlow configuration. This can be done by adding the below to your <code>~/.signalflow/config</code> file: </p> <pre><code>[audio]\noutput_buffer_size = 8192\n</code></pre>"},{"location":"troubleshooting/node_already_playing_exception/","title":"Troubleshooting: NodeAlreadyPlayingException","text":""},{"location":"troubleshooting/node_already_playing_exception/#example","title":"Example","text":"<pre><code>signalflow.NodeAlreadyPlayingException: Node cannot be played as it is already\nplaying\n</code></pre>"},{"location":"troubleshooting/node_already_playing_exception/#description","title":"Description","text":"<p>This exception occurs when <code>play()</code> is called on a <code>Node</code> or <code>Patch</code> object that is already playing.      </p>"},{"location":"troubleshooting/node_already_playing_exception/#solution","title":"Solution","text":"<p>Calling <code>play()</code> on a <code>Node</code> object simply connects the output of that node to the output endpoint of the audio graph, which means that frames will be requested from it in future audio I/O blocks.</p> <p>Calling <code>play()</code> a second time therefore has no effect, because the <code>Node</code> is already connected. </p> <p>If you want to play a particular sound twice, you should instead create two instances of the <code>Node</code> or <code>Patch</code>, and play them individually. So instead of:</p> <pre><code>ping = Ping()\nping.play()\ntime.sleep(1)\nping.play() # incorrect \n</code></pre> <p>You should write:</p> <pre><code>ping = Ping()\nping.play()\ntime.sleep(1)\nping = Ping() # create and play a new Ping \nping.play() \n</code></pre>"},{"location":"troubleshooting/node_not_playing_exception/","title":"Troubleshooting: NodeNotPlayingException","text":""},{"location":"troubleshooting/node_not_playing_exception/#example","title":"Example","text":"<pre><code>signalflow.NodeNotPlayingException: Node cannot be played as it is already\nplaying\n</code></pre>"},{"location":"troubleshooting/node_not_playing_exception/#description","title":"Description","text":"<p>This exception occurs when <code>stop()</code> is called on a <code>Node</code> object that has not yet been played.      </p>"},{"location":"troubleshooting/node_not_playing_exception/#solution","title":"Solution","text":"<p>Calling <code>stop()</code> on a <code>Node</code> object that is not connected to an output is invalid, and should be avoided.</p> <p>If you want to check whether a <code>Node</code> is connected before stopping it, you can check the boolean <code>is_playing</code> property.</p>"}]}